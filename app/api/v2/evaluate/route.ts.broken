import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { Segment, SegmentEvaluation } from '@/lib/types-v2';
import { ProductId } from '@/lib/types';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { validateKnowledgeExcerpt, detectFabricatedContent, logValidationResult } from '@/lib/knowledge-excerpt-validator';
import { createEmbeddingService } from '@/lib/embedding-service';
import { createChromaVectorDB } from '@/lib/vector-db/chroma-db';
import { createRAGSearchService } from '@/lib/rag-search';
import { createNGKeywordValidator } from '@/lib/ng-keyword-validator';
import { analyzePeriodExpressions, validatePeriodConsistency } from '@/lib/period-expression-analyzer';
import { validateGuinnessRecord } from '@/lib/guinness-record-validator';
import { getPromptCache, getRAGCache } from '@/lib/cache';

// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå»¶é•·: é•·æ–‡å‡¦ç†å¯¾å¿œï¼ˆIssue #17ï¼‰
export const maxDuration = 60;

// Initialize global caches for performance optimization
const promptCache = getPromptCache();
const ragCache = getRAGCache();

/**
 * Request schema for evaluation API
 */
const evaluateRequestSchema = z.object({
  segments: z.array(z.object({
    id: z.string(),
    text: z.string(),
    type: z.enum(['claim', 'explanation', 'evidence', 'cta', 'disclaimer']),
    position: z.object({
      start: z.number(),
      end: z.number(),
      line: z.number().optional(),
    }),
    importance: z.number().min(0).max(1).optional(),
    relatedSegments: z.array(z.string()).optional(),
  })),
  productId: z.enum(['HA', 'SH']),
  apiKey: z.string().min(10),
  fullText: z.string().optional(), // Full advertisement text for context
  knowledgeContext: z.string().optional(),
});

type EvaluateRequest = z.infer<typeof evaluateRequestSchema>;

/**
 * POST /api/v2/evaluate
 * RAG-based legal compliance evaluation API
 *
 * Evaluates advertisement segments against legal knowledge base
 * including è–¬æ©Ÿæ³• (Pharmaceutical Affairs Law), æ™¯è¡¨æ³• (Act against Unjustifiable Premiums
 * and Misleading Representations), and internal company standards.
 *
 * @param segments - Array of segments to evaluate
 * @param productId - Product ID (HA or SH)
 * @param apiKey - Gemini API key
 * @param knowledgeContext - Optional pre-loaded knowledge context
 *
 * @returns Array of segment evaluations with violations and corrections
 */
export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    // Parse and validate request body
    const body = await request.json();
    console.log('[Evaluate API] Received request with', body.segments?.length || 0, 'segments');

    const validatedInput: EvaluateRequest = evaluateRequestSchema.parse(body);

    // Validate API key format
    if (!validatedInput.apiKey || validatedInput.apiKey.length < 10) {
      return NextResponse.json({
        success: false,
        error: 'ç„¡åŠ¹ãªGemini APIã‚­ãƒ¼ã§ã™ã€‚æœ‰åŠ¹ãªAPIã‚­ãƒ¼ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚',
      }, { status: 400 });
    }

    // Load knowledge context if not provided
    let knowledgeContext = validatedInput.knowledgeContext;
    if (!knowledgeContext) {
      const combinedSegmentText = validatedInput.segments.map(s => s.text).join('\n');

      // Try to get from cache first (PERFORMANCE OPTIMIZATION)
      const cachedKnowledge = ragCache.get(combinedSegmentText, validatedInput.productId);

      if (cachedKnowledge) {
        console.log('[Evaluate API] ğŸš€ RAG CACHE HIT! Using cached knowledge context');
        knowledgeContext = cachedKnowledge;
      } else {
        console.log('[Evaluate API] RAG Search: Cache miss, performing search...');
        console.log('[Evaluate API] RAG Search: Initializing services...');

        const embeddingService = createEmbeddingService(validatedInput.apiKey);
        const vectorDB = createChromaVectorDB({
          url: process.env.CHROMA_URL || 'http://localhost:8000',
          apiKey: validatedInput.apiKey, // Auto-load knowledge with API key
        });

        await vectorDB.connect();
        const ragSearchService = createRAGSearchService(embeddingService, vectorDB);

        // ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯æ¤œç´¢ã§é–¢é€£ãƒŠãƒ¬ãƒƒã‚¸ã‚’å–å¾—
        console.log('[Evaluate API] RAG Search: Searching for', validatedInput.segments.length, 'segments...');

        const ragResult = await ragSearchService.search(combinedSegmentText, {
          topK: 20,
          minSimilarity: 0.5,
          productId: validatedInput.productId,
          debug: true,
        });

        knowledgeContext = ragResult.relevantKnowledge;

        console.log('[Evaluate API] RAG Search: Found', ragResult.searchResults.length, 'relevant chunks');
        console.log('[Evaluate API] RAG Search: Knowledge context size:', knowledgeContext.length, 'chars');

        // Cache the result for future requests (30 minutes TTL)
        ragCache.set(combinedSegmentText, validatedInput.productId, knowledgeContext, ragResult.searchResults.length, 1800);
        console.log('[Evaluate API] ğŸ’¾ RAG result cached for 30 minutes');

        // Vector DBæ¥ç¶šã‚’é–‰ã˜ã‚‹
        await vectorDB.close();
      }
    } else {
      console.log('[Evaluate API] Using provided knowledge context:', knowledgeContext.length, 'chars');
    }

    // Initialize Gemini client with JSON mode
    // Changed to gemini-2.5-flash-lite (æ­£å¼ç‰ˆã€ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆç”¨)
    // Note: gemini-2.0-flash-exp ã¯ç”»åƒç”Ÿæˆç”¨ã®ãŸã‚çµ¶å¯¾ã«ä½¿ç”¨ç¦æ­¢
    const genAI = new GoogleGenerativeAI(validatedInput.apiKey);
    const model = genAI.getGenerativeModel({
      model: 'gemini-2.5-flash-lite',
      generationConfig: {
        responseMimeType: 'application/json',
        temperature: 0.0, // Zero temperature for maximum consistency and verbatim quoting
      },
    });

    // Evaluate segments with controlled concurrency (max 3 parallel)
    const evaluations: SegmentEvaluation[] = [];
    const batchSize = 1; // Sequential processing to avoid rate limits

    for (let i = 0; i < validatedInput.segments.length; i += batchSize) {
      const batch = validatedInput.segments.slice(i, i + batchSize);
      console.log(`[Evaluate API] Processing batch ${i / batchSize + 1} (${batch.length} segments)`);

      const batchPromises = batch.map(segment =>
        evaluateSegmentWithRetry(
          segment as Segment,
          validatedInput.productId,
          knowledgeContext!,
          model,
          validatedInput.fullText
        )
      );

      const batchResults = await Promise.allSettled(batchPromises);

      // Process results
      for (const result of batchResults) {
        if (result.status === 'fulfilled') {
          evaluations.push(result.value);
        } else {
          console.error('[Evaluate API] Segment evaluation failed:', result.reason);
          // Add error result
          evaluations.push({
            segmentId: batch[batchResults.indexOf(result)].id,
            compliance: false,
            violations: [{
              type: 'ãã®ä»–',
              severity: 'high',
              description: `è©•ä¾¡ã‚¨ãƒ©ãƒ¼: ${result.reason.message}`,
              referenceKnowledge: {
                file: 'system',
                excerpt: 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ',
              },
              correctionSuggestion: 'å†è©•ä¾¡ãŒå¿…è¦ã§ã™',
            }],
            evaluatedAt: new Date().toISOString(),
          });
        }
      }

      // Add adaptive delay between batches to avoid rate limits
      if (i + batchSize < validatedInput.segments.length) {
        const adaptiveDelay = calculateAdaptiveDelay(
          i,
          validatedInput.segments.length,
          15000 // Estimated 15k tokens per request (with knowledge base)
        );
        console.log(`[Evaluate API] Waiting ${Math.round(adaptiveDelay / 1000)}s before next segment...`);
        await delay(adaptiveDelay);
      }
    }

    const processingTime = Date.now() - startTime;
    console.log(`[Evaluate API] Completed ${evaluations.length} evaluations in ${processingTime}ms`);

    // Get cache statistics for performance monitoring
    const ragCacheStats = ragCache.getStats();
    const promptCacheStats = promptCache.getStats();

    console.log(`[Evaluate API] ğŸ“Š Cache Performance:`);
    console.log(`  - RAG Cache: ${ragCacheStats.hits} hits, ${ragCacheStats.misses} misses, ${(ragCacheStats.hitRate * 100).toFixed(1)}% hit rate`);
    console.log(`  - Prompt Cache: ${promptCacheStats.hits} hits, ${promptCacheStats.misses} misses, ${(promptCacheStats.hitRate * 100).toFixed(1)}% hit rate`);

    // Return evaluation results
    return NextResponse.json({
      success: true,
      data: {
        evaluations,
        summary: {
          totalSegments: validatedInput.segments.length,
          evaluatedSegments: evaluations.length,
          compliantSegments: evaluations.filter(e => e.compliance).length,
          violationCount: evaluations.reduce((sum, e) => sum + e.violations.length, 0),
        },
        productId: validatedInput.productId,
        processingTimeMs: processingTime,
        // Cache performance metrics (for monitoring)
        cachePerformance: {
          ragCache: {
            hitRate: ragCacheStats.hitRate,
            hits: ragCacheStats.hits,
            misses: ragCacheStats.misses,
          },
          promptCache: {
            hitRate: promptCacheStats.hitRate,
            hits: promptCacheStats.hits,
            misses: promptCacheStats.misses,
          },
        },
      },
    }, { status: 200 });

  } catch (error: unknown) {
    console.error('[Evaluate API] Error:', error);

    // Zod validation error
    if (error && typeof error === 'object' && 'name' in error && error.name === 'ZodError') {
      const zodError = error as { errors?: Array<{ message: string; path: (string | number)[] }> };
      return NextResponse.json({
        success: false,
        error: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
        details: zodError.errors,
      }, { status: 400 });
    }

    // Gemini API errors
    if (error instanceof Error) {
      if (error.message.includes('API key') || error.message.includes('API_KEY')) {
        return NextResponse.json({
          success: false,
          error: 'Gemini APIã‚­ãƒ¼ãŒç„¡åŠ¹ã§ã™ã€‚æ­£ã—ã„APIã‚­ãƒ¼ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚',
          details: error.message,
        }, { status: 401 });
      }

      if (error.message.includes('quota') || error.message.includes('rate limit') || error.message.includes('429')) {
        return NextResponse.json({
          success: false,
          error: 'APIãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«é”ã—ã¾ã—ãŸã€‚ç´„30ç§’å¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚é•·æ–‡ã®å ´åˆã¯ã€ãƒ†ã‚­ã‚¹ãƒˆã‚’åˆ†å‰²ã—ã¦å‡¦ç†ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚',
          details: error.message,
          retryAfter: 30
        }, { status: 429 });
      }

      // Generic error
      return NextResponse.json({
        success: false,
        error: 'è©•ä¾¡å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
        details: error.message,
      }, { status: 500 });
    }

    // Unknown error
    return NextResponse.json({
      success: false,
      error: 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
    }, { status: 500 });
  }
}

/**
 * Pre-process segment text to detect annotation markers
 * This function explicitly identifies which keywords have annotation markers (â€»1, â€»2, etc.)
 * to prevent AI from misreading the text
 */
interface AnnotationAnalysis {
  keywordsWithMarkers: Array<{ keyword: string; marker: string; fullMatch: string }>;
  keywordsWithoutMarkers: string[];
  allAnnotations: Array<{ marker: string; text: string }>;
}

function analyzeAnnotations(segmentText: string, productId: ProductId): AnnotationAnalysis {
  const analysis: AnnotationAnalysis = {
    keywordsWithMarkers: [],
    keywordsWithoutMarkers: [],
    allAnnotations: [],
  };

  // Extract annotation definitions (â€»1 or *1 è§’è³ªå±¤ã¾ã§, â€»2 or *2 æ®ºèŒã¯æ¶ˆæ¯’ã®ä½œç”¨æ©Ÿåºã¨ã—ã¦, etc.)
  // Updated to support both â€» (kome-jirushi) and * (asterisk) markers
  const annotationDefRegex = /([â€»*])(\d+)\s*[ï¼š:]\s*([^\nâ€»*]+)/g;
  const annotationDefRegex2 = /([â€»*])(\d+)\s+([^\nâ€»*]+)/g;

  let match;
  while ((match = annotationDefRegex.exec(segmentText)) !== null) {
    analysis.allAnnotations.push({
      marker: `${match[1]}${match[2]}`,  // match[1] = â€» or *, match[2] = number
      text: match[3].trim(),              // match[3] = annotation text
    });
  }

  // Reset regex
  annotationDefRegex2.lastIndex = 0;
  while ((match = annotationDefRegex2.exec(segmentText)) !== null) {
    // Avoid duplicates
    const marker = `${match[1]}${match[2]}`;  // match[1] = â€» or *, match[2] = number
    if (!analysis.allAnnotations.some(a => a.marker === marker)) {
      analysis.allAnnotations.push({
        marker: marker,
        text: match[3].trim(),                // match[3] = annotation text
      });
    }
  }

  // Extract keywords with annotation markers directly attached (e.g., æµ¸é€â€»1, æ®ºèŒ*2)
  // Pattern: [ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰][â€» or *][æ•°å­—]
  // Updated to support both â€» (kome-jirushi) and * (asterisk) markers
  const keywordWithMarkerRegex = /([ã-ã‚“ã‚¡-ãƒ¶ãƒ¼ä¸€-é¾ ã€…a-zA-Z]+)([â€»*]\d+)/g;

  const foundKeywordsWithMarkers = new Set<string>();
  while ((match = keywordWithMarkerRegex.exec(segmentText)) !== null) {
    const keyword = match[1];
    const marker = match[2];
    const fullMatch = match[0]; // e.g., "æµ¸é€â€»1"

    analysis.keywordsWithMarkers.push({
      keyword,
      marker,
      fullMatch,
    });
    foundKeywordsWithMarkers.add(keyword);
  }

  // Load product-specific required keywords dynamically FIRST
  let productRequiredKeywords: string[] = [];
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { loadProductConfig } = require('../../../../lib/product-config-loader');
    const config = loadProductConfig(productId);
    productRequiredKeywords = config.segmentationKeywords.required;
    console.log(`[analyzeAnnotations] Loaded ${productRequiredKeywords.length} product-specific keywords for ${productId}:`, productRequiredKeywords);
  } catch (error) {
    console.warn(`[analyzeAnnotations] Failed to load product config for ${productId}:`, error);
  }

  // Extract all potential keywords from the text (katakana and kanji sequences of 2+ chars)
  // This helps identify keywords that might need annotations but don't have markers
  const potentialKeywordRegex = /([ã‚¡-ãƒ¶ãƒ¼]{2,}|[ä¸€-é¾ ã€…]{2,})/g;
  const allPotentialKeywords = new Set<string>();

  while ((match = potentialKeywordRegex.exec(segmentText)) !== null) {
    const keyword = match[1];
    // Skip if this keyword already has a marker attached
    if (!foundKeywordsWithMarkers.has(keyword)) {
      allPotentialKeywords.add(keyword);
    }
  }

  // ğŸ”¥ CRITICAL FIX: Add product-specific required keywords directly
  // This ensures keywords like "ãƒ’ã‚¢ãƒ«ãƒ­ãƒ³é…¸" (katakana+kanji mix) are detected
  // ğŸ› FIX: Only include keywords that actually exist in the segment
  const existingProductKeywords: string[] = [];
  for (const keyword of productRequiredKeywords) {
    // Check if the keyword exists in the segment text
    if (segmentText.includes(keyword)) {
      existingProductKeywords.push(keyword);

      // Add to potential keywords if it doesn't have a marker
      if (!foundKeywordsWithMarkers.has(keyword)) {
        allPotentialKeywords.add(keyword);
        console.log(`[analyzeAnnotations] ğŸ¯ Added product-specific keyword without marker: "${keyword}"`);
      }
    }
  }

  // Log which keywords were found vs not found (for debugging)
  const missingProductKeywords = productRequiredKeywords.filter(kw => !existingProductKeywords.includes(kw));
  if (missingProductKeywords.length > 0) {
    console.log(`[analyzeAnnotations] âš ï¸  Product keywords NOT in segment (will be excluded): ${missingProductKeywords.join(', ')}`);
  }
  console.log(`[analyzeAnnotations] âœ“ Product keywords in segment: ${existingProductKeywords.join(', ') || '(none)'}`);

  // Filter potential keywords to focus on those likely to need annotations
  // Common patterns that often require annotations in cosmetic/pharmaceutical ads
  const likelyNeedsAnnotation = (keyword: string): boolean => {
    // Ingredient-related keywords (katakana is often used for ingredients)
    if (/^[ã‚¡-ãƒ¶ãƒ¼]+$/.test(keyword)) {
      return true;
    }

    // Action/effect keywords (common kanji patterns)
    const actionKeywords = ['æµ¸é€', 'æ®ºèŒ', 'æ¶ˆæ¯’', 'é™¤èŒ', 'æŠ—èŒ', 'é…åˆ', 'æ³¨å…¥', 'åˆ°é”', 'å±Šã',
                           'æ”¹å–„', 'äºˆé˜²', 'å¯¾ç­–', 'ã‚±ã‚¢', 'åŠ¹æœ', 'åŠ¹èƒ½', 'ä½œç”¨', 'æ²»ç™‚'];

    // ğŸ› FIX: Only merge product keywords that actually exist in the segment
    const allActionKeywords = [...actionKeywords, ...existingProductKeywords];

    if (allActionKeywords.some(ak => keyword.includes(ak))) {
      return true;
    }

    return false;
  };

  // Add keywords that likely need annotations to the analysis
  for (const keyword of allPotentialKeywords) {
    if (likelyNeedsAnnotation(keyword)) {
      analysis.keywordsWithoutMarkers.push(keyword);
    }
  }

  return analysis;
}

/**
 * Evaluate a single segment against legal knowledge base
 *
 * @param segment - Segment to evaluate
 * @param productId - Product ID
 * @param knowledgeContext - Knowledge base context
 * @param model - Gemini model instance
 * @param fullText - Full advertisement text for context (optional)
 * @returns Segment evaluation with violations
 */
async function evaluateSegmentWithRetry(
  segment: Segment,
  productId: ProductId,
  knowledgeContext: string,
  model: { generateContent: (prompt: string) => Promise<{ response: { text: () => string } }> },
  fullText?: string,
  maxRetries: number = 3
): Promise<SegmentEvaluation> {
  const startTime = Date.now();

  // Pre-process: Analyze annotations in the segment
  const annotationAnalysis = analyzeAnnotations(segment.text, productId);

  // Log the analysis for debugging
  console.log(`[Evaluate] Annotation analysis for ${segment.id}:`);
  console.log(`  Keywords WITH markers:`, annotationAnalysis.keywordsWithMarkers);
  console.log(`  Keywords WITHOUT markers:`, annotationAnalysis.keywordsWithoutMarkers);
  console.log(`  All annotations:`, annotationAnalysis.allAnnotations);

  // NG Keyword Validation
  const ngKeywordValidator = createNGKeywordValidator();
  const ngValidationResult = ngKeywordValidator.validate(segment.text, fullText);

  console.log(`[Evaluate] NG Keyword validation for ${segment.id}:`);
  console.log(`  Has violations: ${ngValidationResult.hasViolations}`);
  console.log(`  Summary:`, ngValidationResult.summary);
  if (ngValidationResult.hasViolations) {
    console.log(`  Detected NG keywords:`, ngValidationResult.explicitNGKeywordsList);
    console.log(`  Details:`, ngKeywordValidator.getDetailedList(ngValidationResult));
  }

  // Period Expression Validation (FR-TIME-001, FR-TIME-002)
  const periodAnalysis = analyzePeriodExpressions(segment.text, fullText);
  const periodValidation = validatePeriodConsistency(segment.text, fullText);

  console.log(`[Evaluate] Period expression validation for ${segment.id}:`);
  console.log(`  Has period expressions: ${periodAnalysis.expressions.length > 0}`);
  console.log(`  Period consistency: ${periodValidation.isValid ? 'Valid' : 'Invalid'}`);
  if (!periodValidation.isValid) {
    console.log(`  Period violations:`, periodValidation.violations);
  }

  // Guinness Record Validation (FR-GUIN-001, FR-GUIN-002)
  const guinnessValidation = validateGuinnessRecord(segment.text, fullText);

  console.log(`[Evaluate] Guinness record validation for ${segment.id}:`);
  console.log(`  Has Guinness reference: ${guinnessValidation.hasGuinnessReference}`);
  console.log(`  Guinness validation: ${guinnessValidation.isValid ? 'Valid' : 'Invalid'}`);
  if (!guinnessValidation.isValid) {
    console.log(`  Guinness violations:`, guinnessValidation.violations);
  }

  // Note: Knowledge filtering has been disabled to restore correct behavior
  // Previous filtering logic caused false negatives in keyword detection

  const fullTextSection = fullText ? `

## åºƒå‘Šæ–‡å…¨ä½“ï¼ˆæ³¨é‡ˆã‚„ä»–ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å«ã‚€ï¼‰
---
${fullText}
---

**é‡è¦:** ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’è©•ä¾¡ã™ã‚‹éš›ã€åºƒå‘Šæ–‡å…¨ä½“ã«å«ã¾ã‚Œã‚‹æ³¨é‡ˆï¼ˆâ€»1ã€â€»2ãªã©ï¼‰ã‚‚è€ƒæ…®ã—ã¦ãã ã•ã„ã€‚
æ³¨é‡ˆãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®æ³¨é‡ˆã‚’ç¢ºèªã—ã¦ã‹ã‚‰é•ååˆ¤å®šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚
` : '';

  // Pre-detect product-specific keywords in the segment
  const detectedProductKeywords: string[] = [];
  let productAnnotationRulesSection = '';

  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { loadProductConfig } = require('../../../../lib/product-config-loader');
    const config = loadProductConfig(productId);

    // Detect which product-specific keywords are actually in this segment
    for (const keyword of config.segmentationKeywords.required) {
      if (segment.text.includes(keyword)) {
        detectedProductKeywords.push(keyword);
      }
    }

    if (detectedProductKeywords.length > 0) {
      console.log(`[Evaluate] ğŸ¯ Detected product-specific keywords in ${segment.id}: ${detectedProductKeywords.join(', ')}`);

      const detectedRulesList = detectedProductKeywords
        .filter(keyword => config.annotationRules[keyword])
        .map(keyword => {
          const rule = config.annotationRules[keyword];
          console.log(`[Evaluate] ğŸ“Œ Required annotation for "${keyword}": ${rule.template}`);
          return `- ã€Œ${keyword}ã€â†’ å¿…é ˆæ³¨é‡ˆï¼šã€Œ${rule.template}ã€ï¼ˆé‡å¤§åº¦ï¼š${rule.severity === 'high' ? 'é«˜' : 'ä¸­'}ï¼‰`;
        })
        .join('\n');

      productAnnotationRulesSection = `

# ğŸš¨ã€æœ€å„ªå…ˆã€‘ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã§æ¤œå‡ºã•ã‚ŒãŸå•†å“å›ºæœ‰ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ ğŸš¨

**ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«ã¯ä»¥ä¸‹ã®${config.name}ï¼ˆ${productId}ï¼‰å›ºæœ‰ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ï¼š**

${detectedProductKeywords.map(k => `ã€Œ${k}ã€`).join('ã€')}

**ã“ã‚Œã‚‰ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ã¯ä»¥ä¸‹ã®æ³¨é‡ˆãŒå¿…é ˆã§ã™ï¼š**

${detectedRulesList}

**ã€çµ¶å¯¾å³å®ˆã€‘ã“ã‚Œã‚‰ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒâ€»ãƒãƒ¼ã‚«ãƒ¼ãªã—ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã€å¿…ãšé•åã¨ã—ã¦æ¤œå‡ºã—ã¦ãã ã•ã„ï¼**

---
`;
    }
  } catch (error) {
    // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„å ´åˆã¯ç„¡è¦–
    console.error('[Evaluate] Error loading product config:', error);
  }

  // æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ãƒ«ãƒ¼ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆâ€» ã¨ * ã®ä¸¡æ–¹ã‚’æœ‰åŠ¹ãªãƒãƒ¼ã‚«ãƒ¼ã¨ã—ã¦èªè­˜ï¼‰
  const annotationMarkerRulesSection = `

## ğŸ“ã€é‡è¦ã€‘æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ã®èªè­˜ãƒ«ãƒ¼ãƒ«

### æœ‰åŠ¹ãªæ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼å½¢å¼

ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã¯ä»¥ä¸‹ã®æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ã‚’å…¨ã¦èªè­˜ã—ã€æœ‰åŠ¹ãªãƒãƒ¼ã‚«ãƒ¼ã¨ã—ã¦æ‰±ã„ã¾ã™ï¼š

1. **æ¨™æº–å½¢å¼ï¼ˆæ¨å¥¨ï¼‰:** â€»1, â€»2, â€»3, ...
   - ä¾‹: ã‚¯ãƒâ€»1å¯¾ç­–
   - æ³¨é‡ˆ: â€»1 ä¹¾ç‡¥ã‚„å¤ã„è§’è³ªã«ã‚ˆã‚‹ãã™ã¿ã€ãƒãƒªãŒä¸è¶³ã—ãŸæš—ã„ç›®ã®ä¸‹

2. **äº’æ›å½¢å¼:** *1, *2, *3, ... (ã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯)
   - ä¾‹: ã‚¯ãƒ*å¯¾ç­–
   - æ³¨é‡ˆ: *ä¹¾ç‡¥ã‚„å¤ã„è§’è³ªã«ã‚ˆã‚‹ãã™ã¿ã€ãƒãƒªãŒä¸è¶³ã—ãŸæš—ã„ç›®ã®ä¸‹

3. **ç°¡æ˜“å½¢å¼:** â€» ã¾ãŸã¯ * (æ•°å­—ãªã—)
   - ä¾‹: ã‚·ãƒŸå¯¾ç­–â€»
   - æ³¨é‡ˆ: â€»ãƒ¡ãƒ©ãƒ‹ãƒ³ã®ç”Ÿæˆã«ã‚ˆã‚‹ã‚‚ã®

### ã€é‡è¦ã€‘è©•ä¾¡åŸºæº–

- ãƒãƒ¼ã‚«ãƒ¼ã®ç¨®é¡ï¼ˆâ€» ã¾ãŸã¯ *ï¼‰ãŒç•°ãªã£ã¦ã‚‚ã€æ­£ã—ãè¨˜è¼‰ã•ã‚Œã¦ã„ã‚Œã°**é©åˆ**ã¨åˆ¤å®šã—ã¦ãã ã•ã„
- é‡è¦ãªã®ã¯ãƒãƒ¼ã‚«ãƒ¼ã®**å­˜åœ¨**ã¨**å¯¾å¿œã™ã‚‹å®šç¾©ã®å†…å®¹**ã§ã™
- ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã§ * ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã¦ã‚‚ã€å®Ÿéš›ã®ãƒ†ã‚­ã‚¹ãƒˆã§ â€» ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚Œã°é©åˆã§ã™
- é€†ã«ã€ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã§ â€» ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã¦ã‚‚ã€å®Ÿéš›ã®ãƒ†ã‚­ã‚¹ãƒˆã§ * ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚Œã°é©åˆã§ã™

**âŒ èª¤ã£ãŸåˆ¤å®šä¾‹:**
- ãƒ†ã‚­ã‚¹ãƒˆã«ã€Œã‚¯ãƒâ€»1å¯¾ç­–ã€ã¨æ­£ã—ãè¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ã®ã«ã€Œæ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ãŒãªã„ã€ã¨åˆ¤å®šã™ã‚‹ â†’ **èª¤ã‚Š**
- ãƒãƒ¼ã‚«ãƒ¼ã®ç¨®é¡ãŒç•°ãªã‚‹ã ã‘ã§ä¸é©åˆã¨åˆ¤å®šã™ã‚‹ â†’ **èª¤ã‚Š**

**âœ“ æ­£ã—ã„åˆ¤å®šä¾‹:**
- ã€Œã‚¯ãƒâ€»1å¯¾ç­– â€»1 ä¹¾ç‡¥ã‚„...ã€â†’ é©åˆï¼ˆãƒãƒ¼ã‚«ãƒ¼ã‚ã‚Šã€å®šç¾©ã‚ã‚Šï¼‰
- ã€Œã‚¯ãƒ*å¯¾ç­– *ä¹¾ç‡¥ã‚„...ã€â†’ é©åˆï¼ˆã‚¢ã‚¹ã‚¿ãƒªã‚¹ã‚¯ã‚‚æœ‰åŠ¹ï¼‰
- ã€Œã‚¯ãƒå¯¾ç­–ã€â†’ ä¸é©åˆï¼ˆãƒãƒ¼ã‚«ãƒ¼ãªã—ï¼‰
`;

  const annotationAnalysisSection = `

## ã€è‡ªå‹•æ¤œå‡ºã€‘ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼åˆ†æçµæœ

ã‚·ã‚¹ãƒ†ãƒ ãŒäº‹å‰ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’è§£æã—ã€æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ã®æœ‰ç„¡ã‚’æ¤œå‡ºã—ã¾ã—ãŸã€‚
**ä»¥ä¸‹ã®åˆ†æçµæœã«åŸºã¥ã„ã¦è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚ãƒ†ã‚­ã‚¹ãƒˆã‚’å†åº¦èª­ã¿ç›´ã™å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚**

### æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ä»˜ãã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆâ€»è¨˜å·ãŒç›´å¾Œã«ä»˜ã„ã¦ã„ã‚‹ï¼‰
${annotationAnalysis.keywordsWithMarkers.length > 0
  ? annotationAnalysis.keywordsWithMarkers.map(k => `- ã€Œ${k.fullMatch}ã€ â†’ ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€Œ${k.keyword}ã€ã«${k.marker}ãŒä»˜ã„ã¦ã„ã‚‹`).join('\n')
  : '- ãªã—'}

### æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ãªã—ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆâ€»è¨˜å·ãŒä»˜ã„ã¦ã„ãªã„ã€æ³¨é‡ˆãŒå¿…è¦ãªå¯èƒ½æ€§ãŒã‚ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰
${annotationAnalysis.keywordsWithoutMarkers.length > 0
  ? annotationAnalysis.keywordsWithoutMarkers.map(k => `- ã€Œ${k}ã€ â†’ æ³¨é‡ˆè¨˜å·ãªã— â†’ çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‚’ç¢ºèªã—ã¦è©•ä¾¡ãŒå¿…è¦`).join('\n')
  : '- ãªã—ï¼ˆã¾ãŸã¯è‡ªå‹•æ¤œå‡ºã§ããšï¼‰'}

### ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…ã®æ³¨é‡ˆå®šç¾©
${annotationAnalysis.allAnnotations.length > 0
  ? annotationAnalysis.allAnnotations.map(a => `- ${a.marker}: ${a.text}`).join('\n')
  : '- ãªã—'}

**ã€æ¥µã‚ã¦é‡è¦ã€‘è©•ä¾¡æŒ‡ç¤º:**
1. **æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ä»˜ãã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰**ã«ã¤ã„ã¦ã¯ã€å¯¾å¿œã™ã‚‹æ³¨é‡ˆå®šç¾©ã‚’ç¢ºèªã—ã€å†…å®¹ãŒé©åˆ‡ã‹è©•ä¾¡ã—ã¦ãã ã•ã„
2. **æ³¨é‡ˆãƒãƒ¼ã‚«ãƒ¼ãªã—ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰**ã«ã¤ã„ã¦ã¯ã€çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‚’å‚ç…§ã—ã¦é€šå¸¸é€šã‚Šå³æ ¼ã«è©•ä¾¡ã—ã¦ãã ã•ã„
   - ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…ã«æ³¨é‡ˆãŒã‚ã£ã¦ã‚‚ã€ãã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«â€»è¨˜å·ãŒç›´æ¥ä»˜ã„ã¦ã„ãªã‘ã‚Œã°æ³¨é‡ˆã‚’è€ƒæ…®ã—ãªã„
   - **è¤‡æ•°ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã‚Œãã‚Œã‚’å€‹åˆ¥ã«è©•ä¾¡ã—ã€é•åãŒã‚ã‚Œã°ã™ã¹ã¦è¨˜éŒ²ã™ã‚‹**
   - ä¾‹ï¼šã€Œæµ¸é€ã€ã€Œæ®ºèŒã€ãŒä¸¡æ–¹ãƒªã‚¹ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€ä¸¡æ–¹ã‚’å€‹åˆ¥ã«è©•ä¾¡ã—ã€ä¸¡æ–¹ã¨ã‚‚é•åãªã‚‰2ã¤ã®é•åã¨ã—ã¦è¨˜éŒ²
3. ä¸Šè¨˜ã®ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ãªã„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ã¤ã„ã¦ã‚‚ã€ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’ç¢ºèªã—ã€çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã«è©²å½“ã™ã‚‹è¦å®šãŒã‚ã‚Œã°è©•ä¾¡ã—ã¦ãã ã•ã„

`;

  // Detect if this segment contains period-sensitive keywords (Guinness, No.1, etc.)
  const periodSensitiveKeywords = ['å£²ä¸Šä¸–ç•Œä¸€', 'ä¸–ç•Œä¸€', 'ã‚®ãƒã‚¹', 'No.1', 'ãƒŠãƒ³ãƒãƒ¼ãƒ¯ãƒ³', 'ãƒŠãƒ³ãƒãƒ¼1'];
  const hasPeriodSensitiveKeyword = periodSensitiveKeywords.some(keyword =>
    segment.text.includes(keyword)
  );

  const periodValidationSection = hasPeriodSensitiveKeyword ? `

## ğŸ¯ã€ç‰¹åˆ¥æ¤œè¨¼å¿…é ˆã€‘æœŸé–“æ¤œè¨¼ã®ç‰¹åˆ¥æŒ‡ç¤ºï¼ˆã‚®ãƒã‚¹ä¸–ç•Œè¨˜éŒ²â„¢ãƒ»å£²ä¸Šä¸–ç•Œä¸€è¡¨ç¾ï¼‰

**âš ï¸ ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«ã¯æœŸé–“ã«é–¢ã™ã‚‹ç‰¹åˆ¥ãªæ¤œè¨¼ãŒå¿…è¦ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆ${periodSensitiveKeywords.filter(k => segment.text.includes(k)).join('ã€')}ï¼‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ âš ï¸**

### ã€çµ¶å¯¾å³å®ˆã€‘æœŸé–“æ¤œè¨¼ã®å®Ÿè¡Œæ‰‹é †

ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«ã€Œå£²ä¸Šä¸–ç•Œä¸€ã€ã€Œä¸–ç•Œä¸€ã€ã€Œã‚®ãƒã‚¹ã€ã€ŒNo.1ã€ãªã©ã®æœ€ä¸Šç´šè¡¨ç¾ãŒå«ã¾ã‚Œã‚‹å ´åˆã€
ä»¥ä¸‹ã®æ‰‹é †ã§æœŸé–“æ¤œè¨¼ã‚’**å¿…ãšå®Ÿè¡Œ**ã—ã¦ãã ã•ã„ï¼š

#### ã‚¹ãƒ†ãƒƒãƒ—1: æœŸé–“è¡¨è¨˜ã®æŠ½å‡º
- æ³¨é‡ˆå†…ã‹ã‚‰æœŸé–“è¡¨è¨˜ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„
- ä¾‹: ã€Œ2019å¹´3æœˆï½2025å¹´2æœˆã€ã€Œ2020å¹´ï½2024å¹´ã€ã€Œ2020å¹´ï½2025å¹´ã®5å¹´é–“ã€ãªã©
- å¹´æœˆæ—¥ã®è¡¨è¨˜ã‚’æ­£ç¢ºã«èª­ã¿å–ã£ã¦ãã ã•ã„

#### ã‚¹ãƒ†ãƒƒãƒ—2: ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã®æ­£ã—ã„æœŸé–“ã‚’ç¢ºèª
- ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã€Œ44_ã‚®ãƒã‚¹ä¸–ç•Œè¨˜éŒ²â„¢ã«ã¤ã„ã¦.txtã€ã‚’å‚ç…§
- **æ­£ã—ã„æœŸé–“: 2020å¹´ï½2024å¹´ã®5å¹´é–“**
- é–‹å§‹å¹´: 2020å¹´
- çµ‚äº†å¹´: 2024å¹´
- æœŸé–“: 5å¹´é€£ç¶š

#### ã‚¹ãƒ†ãƒƒãƒ—3: å³å¯†ãªæ¯”è¼ƒãƒã‚§ãƒƒã‚¯

ä»¥ä¸‹ã®3é …ç›®ã‚’**ã™ã¹ã¦**ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼š

**âœ… ãƒã‚§ãƒƒã‚¯1: é–‹å§‹å¹´ãŒ2020å¹´ã§ã‚ã‚‹ã‹**
- 2019å¹´ â†’ **é•å**ï¼ˆ1å¹´æ—©ã„ï¼‰
- 2020å¹´ â†’ **OK**
- 2021å¹´ä»¥é™ â†’ **é•å**

**âœ… ãƒã‚§ãƒƒã‚¯2: çµ‚äº†å¹´ãŒ2024å¹´ã§ã‚ã‚‹ã‹**
- 2023å¹´ â†’ **é•å**ï¼ˆ1å¹´çŸ­ã„ï¼‰
- 2024å¹´ â†’ **OK**
- 2025å¹´ä»¥é™ â†’ **é•å**ï¼ˆ1å¹´ä»¥ä¸Šé•·ã„ï¼‰

**âœ… ãƒã‚§ãƒƒã‚¯3: æœŸé–“ã®é•·ã•ï¼ˆæ˜ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ï¼‰**
- ã€ŒNå¹´é–“ã€ã€ŒNå¹´é€£ç¶šã€ã¨æ˜è¨˜ã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯
  - 4å¹´é–“ä»¥ä¸‹ â†’ **é•å**
  - 5å¹´é–“/5å¹´é€£ç¶š â†’ **OK**
  - 6å¹´é–“ä»¥ä¸Š â†’ **é•å**
- å¹´ã®ç¯„å›²ã®ã¿ï¼ˆã€Œ2020å¹´ï½2024å¹´ã€ãªã©ï¼‰ã®å ´åˆã¯ã€é–‹å§‹å¹´ã¨çµ‚äº†å¹´ãŒæ­£ã—ã‘ã‚Œã°**OK**ï¼ˆæœŸé–“ã®é•·ã•ã¯å•ã‚ãªã„ï¼‰

#### ã‚¹ãƒ†ãƒƒãƒ—4: åˆ¤å®šçµæœã®å‡ºåŠ›

**ã€é‡è¦ã€‘å…¨ã¦ã®ãƒã‚§ãƒƒã‚¯ãŒæ­£ã—ã„å ´åˆã¯é©åˆã¨åˆ¤å®šã—ã¦ãã ã•ã„ã€‚**

**âœ… é©åˆã®å ´åˆï¼ˆå…¨ãƒã‚§ãƒƒã‚¯é …ç›®ãŒOKã®å ´åˆï¼‰:**
- ãƒã‚§ãƒƒã‚¯1: é–‹å§‹å¹´ãŒ2020å¹´ â†’ OK
- ãƒã‚§ãƒƒã‚¯2: çµ‚äº†å¹´ãŒ2024å¹´ â†’ OK
- ãƒã‚§ãƒƒã‚¯3: æœŸé–“ãŒ5å¹´é–“/5å¹´é€£ç¶šï¼ˆæ˜ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰ â†’ OKã€ã¾ãŸã¯å¹´ç¯„å›²ã®ã¿ã§OK

â†’ **ã“ã®å ´åˆã¯ã€Œé©åˆã€ã¨åˆ¤å®šã—ã€é•åã¨ã—ã¦å ±å‘Šã—ãªã„ã§ãã ã•ã„ã€‚**
â†’ supportingEvidenceã«ã€ŒæœŸé–“ãŒ2020å¹´ï½2024å¹´ã§æ­£ã—ã„ãŸã‚ã€é•åã¯ã‚ã‚Šã¾ã›ã‚“ã€ãªã©ã¨è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚

**âŒ é•åã®å ´åˆï¼ˆã„ãšã‚Œã‹ã®ãƒã‚§ãƒƒã‚¯é …ç›®ãŒNGã®å ´åˆï¼‰:**

**æœŸé–“ãŒ1ã¤ã§ã‚‚ç•°ãªã‚‹å ´åˆã¯å¿…ãšé•åã¨ã—ã¦æ¤œçŸ¥ã—ã¦ãã ã•ã„ã€‚**

é•åãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å½¢å¼ï¼ˆå¿…ãšã“ã®å½¢å¼ã§è¨˜è¼‰ï¼‰:
\`\`\`
ã€æ™¯è¡¨æ³•é•åãƒ»å„ªè‰¯èª¤èªã€‘æœŸé–“è¡¨è¨˜ãŒèª¤ã£ã¦ã„ã¾ã™ã€‚

è¨˜è¼‰æœŸé–“: ã€Œ[å®Ÿéš›ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹æœŸé–“]ã€
æ­£ã—ã„æœŸé–“: ã€Œ2020å¹´ï½2024å¹´ã®5å¹´é–“ã€
èª¤ã‚Šã®å†…å®¹: [é–‹å§‹å¹´ãŒ1å¹´æ—©ã„ / çµ‚äº†å¹´ãŒ1å¹´é…ã„ / æœŸé–“ãŒ6å¹´ã«ãªã£ã¦ã„ã‚‹ ãªã©ã€å…·ä½“çš„ã«è¨˜è¼‰]

ä¿®æ­£æ–¹æ³•: æ³¨é‡ˆã®æœŸé–“ã‚’ã€Œ2020å¹´ï½2024å¹´ã€ã¾ãŸã¯ã€Œ2020å¹´ï½2024å¹´ã®5å¹´é€£ç¶šã€ã«ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚
\`\`\`

### ã€é‡è¦ã€‘è¦‹é€ƒã—å³ç¦

ã“ã®æ¤œè¨¼ã¯**æœ€å„ªå…ˆ**ã§ã™ã€‚æœŸé–“ãŒ1å¹´ã§ã‚‚ãšã‚Œã¦ã„ã‚‹å ´åˆã¯**å¿…ãšé•åã¨ã—ã¦æ¤œå‡º**ã—ã¦ãã ã•ã„ã€‚
ãŸã ã—ã€**å…¨ã¦ã®ãƒã‚§ãƒƒã‚¯é …ç›®ãŒæ­£ã—ã„å ´åˆã¯é©åˆã¨åˆ¤å®š**ã—ã€é•åã¨ã—ã¦å ±å‘Šã—ãªã„ã§ãã ã•ã„ã€‚
ã€Œæ³¨é‡ˆãŒä¸ååˆ†ã€ã¨ã„ã£ãŸæ›–æ˜§ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã¯ãªãã€ä¸Šè¨˜ã®å…·ä½“çš„ãªå½¢å¼ã§é•åå†…å®¹ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„ã€‚

---
` : '';

  // Enhanced Period and Guinness Validation Instructions (FR-TIME-002, FR-GUIN-002)
  const enhancedValidationSection = `

## ğŸ”ã€æœŸé–“è¡¨ç¾ãƒ»ã‚®ãƒã‚¹è¨˜éŒ² è©³ç´°æ¤œè¨¼çµæœã€‘

${periodValidation.isValid ? 'âœ… æœŸé–“è¡¨ç¾: ä¸€è²«æ€§ã‚ã‚Š' : 'âŒ æœŸé–“è¡¨ç¾: ä¸æ•´åˆã‚’æ¤œå‡º'}

${!periodValidation.isValid ? `
### æ¤œå‡ºã•ã‚ŒãŸæœŸé–“ä¸æ•´åˆ:
${periodValidation.violations.map(v => `
**é•åã‚¿ã‚¤ãƒ—**: ${v.type === 'period_mismatch' ? 'æœŸé–“ä¸ä¸€è‡´' : 'å¹´æ•°è¨ˆç®—ã‚¨ãƒ©ãƒ¼'}
**é‡å¤§åº¦**: ${v.severity === 'high' ? 'é«˜' : 'ä¸­'}
**å†…å®¹**: ${v.description}
**æœŸå¾…å€¤**: ${v.expected}
**å®Ÿéš›ã®å€¤**: ${v.actual}
**ä¿®æ­£æ¡ˆ**: ${v.correctionSuggestion}
`).join('\n')}

**ã€é‡è¦ã€‘ä¸Šè¨˜ã®æœŸé–“ä¸æ•´åˆã‚’é•åã¨ã—ã¦å¿…ãšå ±å‘Šã—ã¦ãã ã•ã„ã€‚**
` : ''}

${guinnessValidation.hasGuinnessReference ? `
### ã‚®ãƒã‚¹è¨˜éŒ²æ¤œè¨¼çµæœ:
${guinnessValidation.isValid ? 'âœ… ã‚®ãƒã‚¹è¨˜éŒ²: æ¤œè¨¼åˆæ ¼' : 'âŒ ã‚®ãƒã‚¹è¨˜éŒ²: é•åã‚’æ¤œå‡º'}

${!guinnessValidation.isValid ? `
#### æ¤œå‡ºã•ã‚ŒãŸã‚®ãƒã‚¹è¨˜éŒ²é•å:
${guinnessValidation.violations.map(v => `
**é•åã‚¿ã‚¤ãƒ—**: ${
  v.type === 'title_mismatch' ? 'èªå®šåä¸ä¸€è‡´' :
  v.type === 'period_mismatch' ? 'æœŸé–“ä¸ä¸€è‡´' :
  v.type === 'product_mismatch' ? 'å¯¾è±¡ç‰©ä¸ä¸€è‡´' :
  'æ³¨é‡ˆä¸å®Œå…¨'
}
**é‡å¤§åº¦**: ${v.severity === 'high' ? 'é«˜' : 'ä¸­'}
**å†…å®¹**: ${v.description}
**æœŸå¾…ã•ã‚Œã‚‹è¡¨è¨˜**: ${v.expected}
**å®Ÿéš›ã®è¡¨è¨˜**: ${v.actual}
**ä¿®æ­£æ¡ˆ**: ${v.correctionSuggestion}
${v.referenceKnowledge ? `**å‚ç…§ãƒŠãƒ¬ãƒƒã‚¸**: ${v.referenceKnowledge.file}` : ''}
`).join('\n')}

**ã€é‡è¦ã€‘ä¸Šè¨˜ã®ã‚®ãƒã‚¹è¨˜éŒ²é•åã‚’å¿…ãšå ±å‘Šã—ã¦ãã ã•ã„ã€‚**
` : ''}
` : ''}

---
`;

  const prompt = `
ã‚ãªãŸã¯åºƒå‘Šè¡¨ç¾ã®æ³•å‹™ãƒã‚§ãƒƒã‚¯ã®å°‚é–€å®¶ã§ã™ã€‚ä»¥ä¸‹ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’å³å¯†ã«è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚

${productAnnotationRulesSection}

${ngValidationResult.instructionsForGemini}

${enhancedValidationSection}

## ğŸš¨ã€æœ€å„ªå…ˆãƒ»çµ¶å¯¾å³å®ˆã€‘çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ãƒ«ãƒ¼ãƒ«é©ç”¨ã®å‰ææ¡ä»¶ ğŸš¨
## çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ãƒ«ãƒ¼ãƒ«é©ç”¨ã®å‰ææ¡ä»¶

çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã®ãƒ«ãƒ¼ãƒ«ã«è¤‡æ•°ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆï¼ˆä¾‹ï¼šã€Œæ®ºèŒâ€»ã‚¸ã‚§ãƒ«ã€ã¯ã€Œæ®ºèŒã€ã¨ã€Œã‚¸ã‚§ãƒ«ã€ã®2ã¤ï¼‰ã€
**ãã®ãƒ«ãƒ¼ãƒ«å†…ã®ã™ã¹ã¦ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…ã«å­˜åœ¨ã—ã¦ã„ã‚‹å ´åˆã®ã¿**ã€ãã®ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨ã§ãã¾ã™ã€‚

**ä¾‹ï¼š**
- âŒ ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã€Œè–¬ç”¨ã‚¸ã‚§ãƒ«ã€ã«å¯¾ã—ã¦ã€Œæ®ºèŒâ€»ã‚¸ã‚§ãƒ«ã€ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨ â†’ èª¤ã‚Šï¼ˆã€Œæ®ºèŒã€ãŒãªã„ï¼‰
- âœ… ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã€Œæ®ºèŒã‚¸ã‚§ãƒ«ã€ã«å¯¾ã—ã¦ã€Œæ®ºèŒâ€»ã‚¸ã‚§ãƒ«ã€ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨ â†’ æ­£ã—ã„

${annotationMarkerRulesSection}

${annotationAnalysisSection}

${periodValidationSection}

# ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæƒ…å ±

**è©•ä¾¡å¯¾è±¡ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãƒ†ã‚­ã‚¹ãƒˆ:**
\`\`\`
${segment.text}
\`\`\`

**ã‚»ã‚°ãƒ¡ãƒ³ãƒˆID:** ${segment.id}
**ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚¿ã‚¤ãƒ—:** ${segment.type}
**å•†å“ID:** ${productId}

## è©•ä¾¡ã®å„ªå…ˆé †ä½

**ä»¥ä¸‹ã®å„ªå…ˆé †ä½ã«å¾“ã£ã¦è©•ä¾¡ã‚’è¡Œã£ã¦ãã ã•ã„:**

### ç¬¬1å„ªå…ˆï¼šç¤¾å†…åŸºæº–ï¼ˆã€è–¬äº‹ãƒ»æ™¯è¡¨æ³•ãƒ»ç¤¾å†…ãƒ«ãƒ¼ãƒ«ã¾ã¨ã‚ã€‘ï¼‰
- å•†å“ã”ã¨ã®ã€è–¬äº‹ãƒ»æ™¯è¡¨æ³•ãƒ»ç¤¾å†…ãƒ«ãƒ¼ãƒ«ã¾ã¨ã‚ã€‘ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æœ€å„ªå…ˆã§å‚ç…§
- ç¤¾å†…åŸºæº–ã§OKã¨åˆ¤å®šã•ã‚Œã‚‹å ´åˆã€æ³•ä»¤ã§NGã§ã‚‚æœ€çµ‚åˆ¤å®šã¯OK
- ä¾‹ï¼šã€Œæ®ºèŒâ€»ã‚¸ã‚§ãƒ« â€»æ®ºèŒã¯æ¶ˆæ¯’ã®ä½œç”¨æ©Ÿåºã¨ã—ã¦ã€â†’ ç¤¾å†…åŸºæº–ã§OK

#### ã€è–¬äº‹ãƒ»æ™¯è¡¨æ³•ãƒ»ç¤¾å†…ãƒ«ãƒ¼ãƒ«ã¾ã¨ã‚ã€‘ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨æ§‹é€ 

ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯2ã¤ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã™ï¼š

**1. ï¼œOKä¾‹ï¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã€Œè¨€ãˆã‚‹ã“ã¨ã€ï¼‰**
- è¡¨å½¢å¼ã§è¨˜è¼‰
- ã‚«ãƒ©ãƒ ï¼šã€Œè¨€ãˆã‚‹ã“ã¨ã€ã€Œç†ç”±ã€ã€Œä¸»ãªé©ç”¨æ³•ä»¤ã€
- è‰²åˆ†ã‘ï¼šç·‘è‰²=ç„¡æ¡ä»¶OKã€èµ¤è‰²=æ¡ä»¶ä»˜ãOKï¼ˆç†ç”±æ¬„ã®æ¡ä»¶ã‚’æº€ãŸã™å ´åˆã®ã¿ï¼‰

**2. ï¼œNGä¾‹ï¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã€Œè¨€ãˆãªã„ã“ã¨ã€ï¼‰**
- è¡¨å½¢å¼ã§è¨˜è¼‰
- ã‚«ãƒ©ãƒ ï¼šã€Œè¨€ãˆãªã„ã“ã¨ã€ã€Œç†ç”±ã€ã€Œä¸»ãªé©ç”¨æ³•ä»¤ã€

#### çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ãƒ«ãƒ¼ãƒ«ã®æ­£ã—ã„èª­ã¿æ–¹

**ãƒ«ãƒ¼ãƒ«ã®è¨˜è¿°å½¢å¼**: ã€Œæ³¨é‡ˆå¯¾è±¡ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€+ã€Œâ€»ã€+ã€Œæ–‡è„ˆãƒ»å‰¤å‹ã€+ã€Œâ€»æ³¨é‡ˆå†…å®¹ã€

**ä¾‹**: ã€Œæ®ºèŒâ€»ã‚¸ã‚§ãƒ« â€»æ®ºèŒã¯æ¶ˆæ¯’ã®ä½œç”¨æ©Ÿåºã¨ã—ã¦ã€

**ãƒ«ãƒ¼ãƒ«ã®æ§‹é€ ã¨æ„å‘³**:
| è¦ç´  | æ„å‘³ | ä¾‹ |
|------|------|-----|
| â€»ã®ç›´å‰ | æ³¨é‡ˆãŒå¿…è¦ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆãƒã‚§ãƒƒã‚¯å¯¾è±¡ï¼‰ | ã€Œæ®ºèŒã€ã€Œæµ¸é€ã€ |
| â€»ã®ç›´å¾Œ | ã“ã®ãƒ«ãƒ¼ãƒ«ãŒé©ç”¨ã•ã‚Œã‚‹æ–‡è„ˆãƒ»å‰¤å‹ï¼ˆå‚è€ƒæƒ…å ±ã®ã¿ï¼‰ | ã€Œã‚¸ã‚§ãƒ«ã€ã€Œ1ã€ |
| â€»ä»¥é™ã®èª¬æ˜ | æ³¨é‡ˆã®å†…å®¹ | ã€Œâ€»æ®ºèŒã¯æ¶ˆæ¯’ã®ä½œç”¨æ©Ÿåºã¨ã—ã¦ã€ |

**ãƒ«ãƒ¼ãƒ«é©ç”¨ã®åˆ¤æ–­åŸºæº–**:
- ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…ã«ã€Œâ€»ã®ç›´å‰ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
- å­˜åœ¨ã—ãªã„ â†’ ã“ã®ãƒ«ãƒ¼ãƒ«ã¯é©ç”¨ã—ãªã„
- å­˜åœ¨ã™ã‚‹ â†’ ã“ã®ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨ã—ã¦è©•ä¾¡

**è©•ä¾¡æ™‚ã®ç¢ºèªãƒ•ãƒ­ãƒ¼**:
1. ã‚¹ãƒ†ãƒƒãƒ—1: ã¾ãšï¼œOKä¾‹ï¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§è©²å½“ã™ã‚‹è¡¨ç¾ã‚’æ¤œç´¢
   - è©²å½“ã™ã‚‹å ´åˆã€ã€Œç†ç”±ã€ã‚«ãƒ©ãƒ ã‚’ç¢ºèªã—ã€æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹ç¢ºèª
2. ã‚¹ãƒ†ãƒƒãƒ—2: ï¼œOKä¾‹ï¼ã«ãªã„å ´åˆã€ï¼œNGä¾‹ï¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§æ¤œç´¢
   - è©²å½“ã™ã‚‹å ´åˆã€NGã¨åˆ¤å®š
3. ã‚¹ãƒ†ãƒƒãƒ—3: ã©ã¡ã‚‰ã«ã‚‚ãªã„å ´åˆã€ä¸€èˆ¬çš„ãªæ³•ä»¤ãƒ«ãƒ¼ãƒ«ã§è©•ä¾¡

### ç¬¬2å„ªå…ˆï¼šå„ç¨®æ³•ä»¤ï¼ˆè–¬æ©Ÿæ³•ã€æ™¯è¡¨æ³•ã€ç‰¹å•†æ³•ãªã©ï¼‰
- ç¤¾å†…åŸºæº–ã§OKã¨æ˜ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æ³•ä»¤ä¸Šã®æ‡¸å¿µãŒã‚ã£ã¦ã‚‚ç¤¾å†…åŸºæº–ã‚’å„ªå…ˆ

### ç¬¬3å„ªå…ˆï¼šå„ç¨®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³
- æ¥­ç•Œã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã€åšç”ŸåŠ´åƒçœã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã€æ¶ˆè²»è€…åºã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ãªã©

## RAGæ¤œç´¢ã¨é¡ä¼¼è¡¨ç¾æ¤œå‡ºã®å¼·åŒ–

### é¡ä¼¼è¡¨ç¾ãƒ»è¨€ã„æ›ãˆè¡¨ç¾ã®æ¤œå‡ºãƒ«ãƒ¼ãƒ«

åºƒå‘Šæ–‡ã§ã¯åŒã˜æ„å‘³ã‚’æŒã¤è¡¨ç¾ãŒæ§˜ã€…ãªå½¢ã§è¨˜è¼‰ã•ã‚Œã¾ã™ã€‚çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã®è¨˜è¼‰ã¨å®Œå…¨ä¸€è‡´ã—ãªãã¦ã‚‚ã€**æ„å‘³ãŒåŒã˜ãƒ»é¡ä¼¼ã™ã‚‹è¡¨ç¾**ã‚’æ¤œå‡ºã—ã€é©åˆ‡ã«è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚

#### æ¤œå‡ºã™ã¹ãé¡ä¼¼è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³

**1. æµ¸é€è¡¨ç¾ã®é¡ä¼¼ãƒ‘ã‚¿ãƒ¼ãƒ³**
- åŸºæœ¬å½¢: ã€Œæµ¸é€ã€ã€ŒæŸ“ã¿è¾¼ã‚€ã€ã€Œå±Šãã€ã€Œåˆ°é”ã€
- å¼·èª¿å½¢: ã€Œç›´æ¥æµ¸é€ã€ã€Œæ·±ãæµ¸é€ã€ã€Œå¥¥ã¾ã§æµ¸é€ã€
- è¨€ã„æ›ãˆ: ã€Œæ³¨å…¥ã€ã€Œå°å…¥ã€ã€Œãƒ‡ãƒªãƒãƒªãƒ¼ã€

**2. åŠ¹æœè¡¨ç¾ã®è¨€ã„æ›ãˆ**
- ã‚·ãƒ¯: ã€Œã—ã‚ã€ã€Œçšºã€ã€Œå°ã˜ã‚ã€ã€Œå°ã‚¸ãƒ¯ã€
- ã‚·ãƒŸ: ã€Œã—ã¿ã€ã€Œãã°ã‹ã™ã€ã€Œè‰²ç´ æ²ˆç€ã€
- ç¾ç™½: ã€Œãƒ›ãƒ¯ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ã€ã€Œãƒ–ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ã€

**3. æ•°å€¤ãƒ»é †ä½è¡¨ç¾**
- No.1: ã€ŒãƒŠãƒ³ãƒãƒ¼ãƒ¯ãƒ³ã€ã€Œç¬¬1ä½ã€ã€Œ1ä½ã€ã€Œãƒˆãƒƒãƒ—ã€
- ä¸–ç•Œä¸€: ã€Œä¸–ç•ŒNo.1ã€ã€Œä¸–ç•Œæœ€å¤§ã€ã€Œä¸–ç•Œãƒˆãƒƒãƒ—ã€

## ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…ã®æ³¨é‡ˆã®è€ƒæ…®

**æ³¨é‡ˆè¨˜å·ï¼ˆâ€»1ã€â€»2ãªã©ï¼‰ãŒæ˜ç¤ºçš„ã«ä»˜ã„ã¦ã„ã‚‹è¡¨ç¾ã®ã¿ã€æ³¨é‡ˆã‚’è€ƒæ…®ã—ã¾ã™ã€‚**

### è©•ä¾¡å‰ã®å¿…é ˆç¢ºèªäº‹é …

ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’ä¸€å­—ä¸€å¥ã€æ­£ç¢ºã«èª­ã¿å–ã£ã¦ãã ã•ã„ï¼š
**ã€Œ${segment.text}ã€**

**ç¢ºèªãƒã‚¤ãƒ³ãƒˆ:**
1. å„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ç›´å¾Œã«â€»è¨˜å·ï¼ˆâ€»1ã€â€»2ãªã©ï¼‰ãŒä»˜ã„ã¦ã„ã‚‹ã‹ç¢ºèª
   - âœ… ã€Œæµ¸é€â€»1ã€ â†’ æ³¨é‡ˆè¨˜å·ã‚ã‚Š
   - âŒ ã€Œæµ¸é€ã€ â†’ æ³¨é‡ˆè¨˜å·ãªã—

2. ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¨â€»è¨˜å·ã®é–“ã«ã‚¹ãƒšãƒ¼ã‚¹ã‚„å¥èª­ç‚¹ãŒãªã„ã‹ç¢ºèª
   - âœ… ã€Œæµ¸é€â€»1ã€ â†’ ç›´å¾Œã«ä»˜ã„ã¦ã„ã‚‹ï¼ˆOKï¼‰
   - âŒ ã€Œæµ¸é€ â€»1ã€ â†’ ã‚¹ãƒšãƒ¼ã‚¹ãŒã‚ã‚‹ï¼ˆæ³¨é‡ˆè¨˜å·ãªã—ã¨ã¿ãªã™ï¼‰

### æ³¨é‡ˆè©•ä¾¡ã®å¤§åŸå‰‡

**åŸå‰‡1: æ³¨é‡ˆè¨˜å·ãŒã‚ã‚‹è¡¨ç¾ã®ã¿æ³¨é‡ˆã‚’è€ƒæ…®**
- ã€Œæµ¸é€â€»1ã€ã®ã‚ˆã†ã«ã€â€»è¨˜å·ãŒä»˜ã„ã¦ã„ã‚‹å ´åˆã®ã¿ã€å¯¾å¿œã™ã‚‹æ³¨é‡ˆã‚’æ¢ã™
- æ³¨é‡ˆè¨˜å·ãŒãªã„è¡¨ç¾ã¯ã€æ³¨é‡ˆãŒã‚ã£ã¦ã‚‚é–¢ä¿‚ãªãã€é€šå¸¸é€šã‚Šå³æ ¼ã«è©•ä¾¡

**åŸå‰‡2: å„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å€‹åˆ¥ã«è©•ä¾¡**
- ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå†…ã®å…¨ã¦ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æœ€å¾Œã¾ã§ç¢ºèªã—ã€ãã‚Œãã‚Œå€‹åˆ¥ã«è©•ä¾¡
- ä¾‹: ã€Œæµ¸é€â€»1ãƒ»æ®ºèŒã™ã‚‹ã€ã®å ´åˆ
  - ã€Œæµ¸é€â€»1ã€ â†’ â€»è¨˜å·ã‚ã‚Š â†’ æ³¨é‡ˆâ€»1ã‚’ç¢ºèª
  - ã€Œæ®ºèŒã€ â†’ â€»è¨˜å·ãªã— â†’ é€šå¸¸é€šã‚Šå³æ ¼ã«è©•ä¾¡

**åŸå‰‡3: é•åã¯å…¨ã¦æ¤œå‡º**
- 1ã¤ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«è¤‡æ•°ã®é•åãŒã‚ã‚‹å ´åˆã€ãã‚Œãã‚Œã‚’ç‹¬ç«‹ã—ãŸé•åã¨ã—ã¦è¨˜éŒ²

### è©•ä¾¡ä¾‹

**âŒ NGä¾‹: ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã€Œæµ¸é€â€»1ãƒ»æ®ºèŒã™ã‚‹\nâ€»1 è§’è³ªå±¤ã¾ã§ã€**
- ã€Œæµ¸é€â€»1ã€: æ³¨é‡ˆã‚ã‚Š â†’ é•åãªã—
- ã€Œæ®ºèŒã€: æ³¨é‡ˆè¨˜å·ãªã— â†’ ç¤¾å†…åŸºæº–é•å

**âœ… OKä¾‹: ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã€Œæµ¸é€â€»1ãƒ»æ®ºèŒâ€»2ã™ã‚‹\nâ€»1 è§’è³ªå±¤ã¾ã§\nâ€»2 æ®ºèŒã¯æ¶ˆæ¯’ã®ä½œç”¨æ©Ÿåºã¨ã—ã¦ã€**
- ã€Œæµ¸é€â€»1ã€: æ³¨é‡ˆã‚ã‚Šã€å†…å®¹OK â†’ é•åãªã—
- ã€Œæ®ºèŒâ€»2ã€: æ³¨é‡ˆã‚ã‚Šã€å†…å®¹OK â†’ é•åãªã—

### æ³¨é‡ˆå†…å®¹ã®è©•ä¾¡åŸºæº–

**a) å£²ä¸ŠNo.1ãƒ»ä¸–ç•Œä¸€ãªã©ã®è¡¨ç¤º**
- èª¿æŸ»æ©Ÿé–¢åã€èª¿æŸ»æœŸé–“ã€èª¿æŸ»å¯¾è±¡ç¯„å›²ãŒæ˜è¨˜ã•ã‚Œã¦ã„ã‚‹ã‹
- ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã®æƒ…å ±ã¨çŸ›ç›¾ã—ã¦ã„ãªã„ã‹

**b) ãƒªãƒ”ãƒ¼ãƒˆç‡ã®è¡¨ç¤º**
- ç®—å‡ºæœŸé–“ã€ç®—å‡ºæ–¹æ³•ãŒæ˜è¨˜ã•ã‚Œã¦ã„ã‚‹ã‹

**c) ã‚®ãƒã‚¹ä¸–ç•Œè¨˜éŒ²â„¢ã®è¡¨ç¤º**
- èªå®šã•ã‚Œã¦ã„ã‚‹å•†å“ã‹ã€èªå®šæœŸé–“ãŒæ­£ã—ã„ã‹
- è¡¨ç¤ºå†…å®¹ã¨å®Ÿéš›ã®èªå®šå†…å®¹ãŒä¸€è‡´ã—ã¦ã„ã‚‹ã‹

**è©•ä¾¡ä¾‹:**
- âŒ ã€Œ6å¹´é€£ç¶šå£²ä¸Šä¸–ç•Œä¸€â€»1ã€ æ³¨é‡ˆ: ã€Œâ€»1ï¼š2019å¹´3æœˆï½2025å¹´2æœˆï¼ˆ6å¹´ï¼‰ã€ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹: ã€Œ2020å¹´~2024å¹´ã®5å¹´é€£ç¶šã§èªå®šã€â†’ é•åï¼ˆè¡¨ç¤ºã¯6å¹´ã ãŒã€èªå®šã¯5å¹´ã®ã¿ï¼‰
- âœ… ã€Œ5å¹´é€£ç¶šå£²ä¸Šä¸–ç•Œä¸€â€»1ã€ æ³¨é‡ˆ: ã€Œâ€»1ï¼š2020å¹´~2024å¹´ã€ã‚®ãƒã‚¹ä¸–ç•Œè¨˜éŒ²â„¢èªå®šã€ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹: ã€Œ2020å¹´~2024å¹´ã®5å¹´é€£ç¶šã§èªå®šã€â†’ é©åˆ

## æ­£ã—ã„åˆ¤å®šä¾‹ï¼ˆFew-shot Examplesï¼‰

### ä¾‹1: ç¤¾å†…åŸºæº–å„ªå…ˆï¼ˆã€ŒåŒ»å¸«ã‚‚æ•™ãˆãªã„ã€+ã€Œæ®ºèŒã‚¸ã‚§ãƒ«ã€ï¼‰
**ãƒ†ã‚­ã‚¹ãƒˆ:** "åŒ»å¸«ã‚‚æ•™ãˆãªã„æ±šã„çˆªã‚’ã‚­ãƒ¬ã‚¤ã«ã™ã‚‹æ®ºèŒã‚¸ã‚§ãƒ«"
**åˆ¤å®š:** ã€Œæ®ºèŒã‚¸ã‚§ãƒ«ã€ã«æ³¨é‡ˆãŒãªã„ â†’ ç¤¾å†…åŸºæº–é•å
**é‡è¦:** ã€ŒåŒ»å¸«ã‚‚æ•™ãˆãªã„ã€ã¯ç¤¾å†…åŸºæº–ã§OKã€‚åŒã˜è¡¨ç¾ã§ã‚‚ç¤¾å†…åŸºæº–ã¨ä¸€èˆ¬æ³•ä»¤ãŒçŸ›ç›¾ã™ã‚‹å ´åˆã€ç¤¾å†…åŸºæº–ã‚’å„ªå…ˆã€‚

### ä¾‹2: è¤‡åˆé•åï¼ˆã€Œãƒ’ã‚¢ãƒ«ãƒ­ãƒ³é…¸ç›´æ³¨å…¥ã€ï¼‰
**ãƒ†ã‚­ã‚¹ãƒˆ:** "ãƒ’ã‚¢ãƒ«ãƒ­ãƒ³é…¸ç›´æ³¨å…¥ã§"
**é•å:** â‘ ãƒ’ã‚¢ãƒ«ãƒ­ãƒ³é…¸ã«é…åˆç›®çš„ãªã— â‘¡ç›´æ³¨å…¥ã«è§’è³ªå±¤æ˜è¨˜ãªã— â†’ 2ã¤ã®ç¤¾å†…åŸºæº–é•å

### ä¾‹3: ãƒ†ã‚­ã‚¹ãƒˆã«å«ã¾ã‚Œãªã„è¡¨ç¾ã®èª¤æ¤œå‡ºé˜²æ­¢
**ãƒ†ã‚­ã‚¹ãƒˆ:** "ç›®å…ƒã®è€ã‘è¦‹ãˆå°è±¡å¯¾ç­–"
**é•å:** ã€Œè€ã‘è¦‹ãˆå°è±¡å¯¾ç­–ã€ãŒåŠ¹èƒ½åŠ¹æœ56é …ç›®å¤– â†’ è–¬æ©Ÿæ³•é•å
**é‡è¦:** ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã«ã¯ã€Œãƒ’ã‚¢ãƒ«ãƒ­ãƒ³é…¸ã€ã‚‚ã€Œç›´æ³¨å…¥ã€ã‚‚å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ã€ãã‚Œã‚‰ã®é•åã‚’æŒ‡æ‘˜ã—ã¦ã¯ã„ã‘ãªã„ã€‚

### ä¾‹4: ç‰¹å•†æ³•é•åï¼ˆã€Œã„ã¾ãªã‚‰ã€ï¼‰
**ãƒ†ã‚­ã‚¹ãƒˆ:** "ã„ã¾ãªã‚‰ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ã§åŠé¡ã®1,815å††ï¼ˆç¨è¾¼ï¼‰"
**é•å:** ã€Œã„ã¾ãªã‚‰ã€= æœŸé™ã‚’æ˜ç¤ºã—ãªã„é™å®šè¡¨ç¾ â†’ ç‰¹å•†æ³•é•å
**ä¿®æ­£:** ã€Œã“ã®ãƒšãƒ¼ã‚¸ã‹ã‚‰ç”³è¾¼ã‚€ã¨ã€ã¾ãŸã¯ã€Œã„ã¾ãªã‚‰ã€ã‚’å‰Šé™¤

## è©•ä¾¡åŸºæº–

**è©•ä¾¡ã¯ä»¥ä¸‹ã®å„ªå…ˆé †ä½ã§å®Ÿæ–½ã—ã¾ã™ï¼š**

1. **ç¤¾å†…åŸºæº–é•åã®æœ‰ç„¡ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰**
   - ã€è–¬äº‹ãƒ»æ™¯è¡¨æ³•ãƒ»ç¤¾å†…ãƒ«ãƒ¼ãƒ«ã¾ã¨ã‚ã€‘ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹å•†å“å›ºæœ‰ã®ãƒ«ãƒ¼ãƒ«ã‚’ç¢ºèª
   - ç¤¾å†…åŸºæº–ã§OKã¨æ˜ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€æ³•ä»¤ä¸Šã®æ‡¸å¿µãŒã‚ã£ã¦ã‚‚æœ€çµ‚åˆ¤å®šã¯OK

2. **è–¬æ©Ÿæ³•é•åã®æœ‰ç„¡ã‚’ãƒã‚§ãƒƒã‚¯**
   - åŒ»è–¬å“çš„ãªåŠ¹èƒ½åŠ¹æœã®æ¨™æ¦œã€æ‰¿èªã•ã‚Œã¦ã„ãªã„åŠ¹èƒ½åŠ¹æœã®è¡¨ç¤ºã€è™šå½èª‡å¤§åºƒå‘Š
   - ãŸã ã—ã€ç¤¾å†…åŸºæº–ã§OKã¨æ˜ç¤ºã•ã‚Œã¦ã„ã‚‹è¡¨ç¾ã¯é™¤å¤–

3. **æ™¯è¡¨æ³•é•åã®æœ‰ç„¡ã‚’ãƒã‚§ãƒƒã‚¯**
   - å„ªè‰¯èª¤èªè¡¨ç¤ºã€æœ‰åˆ©èª¤èªè¡¨ç¤ºã€æ ¹æ‹ ã®ãªã„æœ€ä¸Šç´šè¡¨ç¾
   - ãŸã ã—ã€ç¤¾å†…åŸºæº–ã§OKã¨æ˜ç¤ºã•ã‚Œã¦ã„ã‚‹è¡¨ç¾ã¯é™¤å¤–

4. **ç‰¹å•†æ³•é•åã®æœ‰ç„¡ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå…¨å•†å“å…±é€šï¼‰**
   ãƒ†ã‚­ã‚¹ãƒˆã«ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ç‰¹å•†æ³•é•åã¨ã—ã¦æ¤œçŸ¥ï¼š
   - ã€Œã„ã¾ãªã‚‰ã€ã€Œä»Šãªã‚‰ã€ã€Œä»Šã ã‘ã€ã€ŒæœŸé–“é™å®šã€ã€Œæœ¬æ—¥é™ã‚Šã€ã€Œçµ‚äº†é–“è¿‘ã€ã€Œé™å®šã€ã€Œå…ˆç€ã€ï¼ˆæ•°é‡ã‚„æœŸé–“ã®æ˜ç¤ºãŒãªã„å ´åˆï¼‰

   **æ¤œçŸ¥ä¾‹:**
   - âŒ NG: ã€Œã„ã¾ãªã‚‰ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆå›ç­”ã§åŠé¡ã€ â†’ ç‰¹å•†æ³•é•å
   - âœ… OK: ã€Œä»Šç”³è¾¼ã‚€ã¨55%OFFã€ â†’ å•é¡Œãªã—

## é‡è¦åº¦ãƒ¬ãƒ™ãƒ«
- high: æ³•çš„ãƒªã‚¹ã‚¯ãŒé«˜ãã€å³åº§ã«ä¿®æ­£ãŒå¿…è¦
- medium: æ³¨æ„ãŒå¿…è¦ã ãŒã€æ¡ä»¶ä»˜ãã§è¨±å®¹ã•ã‚Œã‚‹å¯èƒ½æ€§ã‚ã‚Š
- low: æ¨å¥¨äº‹é …ãƒ¬ãƒ™ãƒ«

## æœ€çµ‚ç¢ºèª

è©•ä¾¡ã‚’é–‹å§‹ã™ã‚‹å‰ã«ã€ã‚‚ã†ä¸€åº¦ç¢ºèªã—ã¦ãã ã•ã„ï¼š

1. **ã“ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®ãƒ†ã‚­ã‚¹ãƒˆ**: ã€Œ${segment.text}ã€
2. **è©•ä¾¡å¯¾è±¡**: ã“ã®ãƒ†ã‚­ã‚¹ãƒˆã«å®Ÿéš›ã«å«ã¾ã‚Œã¦ã„ã‚‹è¡¨ç¾ã®ã¿
3. **è©•ä¾¡å¯¾è±¡å¤–**: ã“ã®ãƒ†ã‚­ã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ãªã„è¡¨ç¾ï¼ˆä»–ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®å†…å®¹ãªã©ï¼‰

âœ… ãƒ†ã‚­ã‚¹ãƒˆã«ã€Œãƒ’ã‚¢ãƒ«ãƒ­ãƒ³é…¸ã€ã¨ã„ã†è¨€è‘‰ãŒå®Ÿéš›ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ã€é…åˆç›®çš„ã®è¨˜è¼‰ã‚’ãƒã‚§ãƒƒã‚¯
âœ… ãƒ†ã‚­ã‚¹ãƒˆã«ã€Œæµ¸é€ã€ã€Œæ³¨å…¥ã€ãªã©ã®è¨€è‘‰ãŒå®Ÿéš›ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ã€è§’è³ªå±¤ã®æ˜è¨˜ã‚’ãƒã‚§ãƒƒã‚¯
âŒ ãƒ†ã‚­ã‚¹ãƒˆã«å«ã¾ã‚Œã¦ã„ãªã„è¨€è‘‰ã«ã¤ã„ã¦é•åã‚’æŒ‡æ‘˜ã—ãªã„

## å‡ºåŠ›å½¢å¼
ä»¥ä¸‹ã®JSONå½¢å¼ã§å³å¯†ã«è¿”ã—ã¦ãã ã•ã„ï¼š
{
  "segmentId": "${segment.id}",
  "compliance": true | false,
  "violations": [
    {
      "type": "ç¤¾å†…åŸºæº–é•å" | "è–¬æ©Ÿæ³•é•å" | "æ™¯è¡¨æ³•é•å" | "ç‰¹å•†æ³•é•å" | "ãã®ä»–",
      "severity": "high" | "medium" | "low",
      "description": "å…·ä½“çš„ãªé•åå†…å®¹ã®è©³ç´°èª¬æ˜ï¼ˆã©ã®è¡¨ç¾ãŒã©ã®æ¡æ–‡ãƒ»åŸºæº–ã«æŠµè§¦ã™ã‚‹ã‹ï¼‰",
      "referenceKnowledge": {
        "file": "å‚ç…§ã—ãŸçŸ¥è­˜ãƒ•ã‚¡ã‚¤ãƒ«å",
        "excerpt": "çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‹ã‚‰è©²å½“ç®‡æ‰€ã‚’ä¸€å­—ä¸€å¥ãã®ã¾ã¾å¼•ç”¨"
      },
      "correctionSuggestion": "çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã«åŸºã¥ã„ãŸå…·ä½“çš„ãªä¿®æ­£æ¡ˆ",
      "confidence": 0.0ã‹ã‚‰1.0ã®æ•°å€¤ï¼ˆã“ã®é•ååˆ¤å®šã®ç¢ºä¿¡åº¦ï¼‰
    }
  ],
  "supportingEvidence": ["é©åˆã—ã¦ã„ã‚‹ç†ç”±ã‚„æ ¹æ‹ ï¼ˆcomplianceãŒtrueã®å ´åˆï¼‰"]
}

**é‡è¦ï¼štypeã®å„ªå…ˆé †ä½**
- åŒã˜è¡¨ç¾ã«ã¤ã„ã¦è¤‡æ•°ã®åŸºæº–ã«æŠµè§¦ã™ã‚‹å ´åˆã€æœ€ã‚‚å„ªå…ˆåº¦ã®é«˜ã„åŸºæº–ã‚’typeã¨ã—ã¦ä½¿ç”¨
- ä¾‹ï¼šç¤¾å†…åŸºæº–ã¨è–¬æ©Ÿæ³•ã®ä¸¡æ–¹ã«æŠµè§¦ã™ã‚‹å ´åˆ â†’ "ç¤¾å†…åŸºæº–é•å"ã‚’ä½¿ç”¨

## ãƒŠãƒ¬ãƒƒã‚¸å¼•ç”¨ã®çµ¶å¯¾ãƒ«ãƒ¼ãƒ«

### ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã®å¾¹åº•

**referenceKnowledge.excerptã¯ã€çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©²å½“ç®‡æ‰€ã‚’ã€Œã‚³ãƒ”ãƒ¼ã€ã—ã¦ã€Œãƒšãƒ¼ã‚¹ãƒˆã€ã™ã‚‹ã ã‘ã§ã™ã€‚**
**ä¸€åˆ‡ã®è¦ç´„ã€è¨€ã„æ›ãˆã€è§£é‡ˆã€ç‹¬è‡ªè¡¨ç¾ã®è¿½åŠ ã¯çµ¶å¯¾ç¦æ­¢ã§ã™ã€‚**

**æ‰‹é †:**
1. çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è©²å½“ç®‡æ‰€ã‚’è¦‹ã¤ã‘ã‚‹
2. ãã®ç®‡æ‰€ã®è¦‹å‡ºã—ï¼ˆ###ã‚„####ï¼‰ã‚‚å«ã‚ã¦ã€ãã®ã¾ã¾ã‚³ãƒ”ãƒ¼
3. referenceKnowledge.excerptã«ä¸€åˆ‡å¤‰æ›´ã›ãšãƒšãƒ¼ã‚¹ãƒˆ

### å®Ÿéš›ã«ç™ºç”Ÿã—ã¦ã„ã‚‹èª¤ã‚Šã¨æ­£ã—ã„å¼•ç”¨æ–¹æ³•

#### âŒ èª¤ã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³1: AIç‹¬è‡ªã®å†…å®¹ã‚’æé€ ï¼ˆã‚¯ãƒè¡¨ç¾ã®ä¾‹ï¼‰

**çµ¶å¯¾ã«ã‚„ã£ã¦ã¯ã„ã‘ãªã„èª¤ã£ãŸå¼•ç”¨:**
{ "referenceKnowledge": { "file": "25_ã‚¯ãƒè¡¨ç¾ã«ã¤ã„ã¦.txt", "excerpt": "ã‚¯ãƒã¨ã„ã†è¡¨ç¾ã‚’ä½¿ã†å ´åˆã€ãƒ¡ãƒ¼ã‚­ãƒ£ãƒƒãƒ—åŠ¹æœã«ã‚ˆã‚‹ã¨ã„ã†æ³¨é‡ˆãŒå¿…è¦ã§ã™ã€‚" } }

**âŒ ãªãœNG:** ã€Œãƒ¡ãƒ¼ã‚­ãƒ£ãƒƒãƒ—åŠ¹æœã«ã‚ˆã‚‹ã€ã¨ã„ã†æ³¨é‡ˆã¯çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã«å­˜åœ¨ã—ã¾ã›ã‚“ã€‚ã“ã‚Œã¯AIãŒå‹æ‰‹ã«ä½œã£ãŸå†…å®¹ã§ã™ã€‚

**âœ… æ­£ã—ã„å¼•ç”¨æ–¹æ³•:**
{ "referenceKnowledge": { "file": "25_ã‚¯ãƒè¡¨ç¾ã«ã¤ã„ã¦.txt", "excerpt": "##### **ã€Œã‚¯ãƒã€ã¨ã„ã†è¡¨ç¾ã‚’ä½¿ã„ãŸã„æ™‚**\\nä»¥ä¸‹ã®æ³¨è¨˜ã¨ã‚»ãƒƒãƒˆã§ä½¿ç”¨ã—ã¦ä¸‹ã•ã„ã€‚\\nâ€»ä¹¾ç‡¥ã‚„å¤ã„è§’è³ªã«ã‚ˆã‚‹ãã™ã¿ã€ãƒãƒªãŒä¸è¶³ã—ãŸæš—ã„ç›®ã®ä¸‹" } }

#### âŒ èª¤ã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³2: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ç¹°ã‚Šè¿”ã—ï¼ˆã‚®ãƒã‚¹ä¸–ç•Œè¨˜éŒ²ã®ä¾‹ï¼‰

**çµ¶å¯¾ã«ã‚„ã£ã¦ã¯ã„ã‘ãªã„èª¤ã£ãŸå¼•ç”¨:**
{ "referenceKnowledge": { "file": "44_ã‚®ãƒã‚¹ä¸–ç•Œè¨˜éŒ²â„¢ã«ã¤ã„ã¦.txt", "excerpt": "å£²ä¸Šä¸–ç•Œä¸€â€»1 å£²ä¸Šä¸–ç•Œä¸€â€»1 å£²ä¸Šä¸–ç•Œä¸€â€»1" } }

**âŒ ãªãœNG:** ã“ã‚Œã¯çŸ¥è­˜ãƒ™ãƒ¼ã‚¹å†…ã®OKä¾‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¹°ã‚Šè¿”ã—ã¦ã„ã‚‹ã ã‘ã§ã€é•åã®èª¬æ˜ã«ãªã£ã¦ã„ã¾ã›ã‚“ã€‚

**âœ… æ­£ã—ã„å¼•ç”¨æ–¹æ³•:**
{ "referenceKnowledge": { "file": "44_ã‚®ãƒã‚¹ä¸–ç•Œè¨˜éŒ²â„¢ã«ã¤ã„ã¦.txt", "excerpt": "#### âŒ NGä¾‹1: é–‹å§‹å¹´ãŒæ—©ã™ãã‚‹\\n\\n**èª¤:** 2019å¹´3æœˆï½2025å¹´2æœˆ\\n**ç†ç”±:** é–‹å§‹å¹´ãŒ2019å¹´ã¨ãªã£ã¦ãŠã‚Šã€æ­£ã—ã„2020å¹´ã‚ˆã‚Š1å¹´æ—©ã„\\n**é•åå†…å®¹:** å®Ÿéš›ã‚ˆã‚Šé•·ã„æœŸé–“ã‚’è¨´æ±‚ï¼ˆå„ªè‰¯èª¤èªï¼‰" } }

### ãƒ«ãƒ¼ãƒ«: referenceKnowledge.excerpt ã®ä½œæˆæ–¹æ³•

1. ä¸Šè¨˜ã®ã€Œé©ç”¨ã•ã‚Œã‚‹çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰è©²å½“ã™ã‚‹è¦å®šã‚’æ­£ç¢ºã«æ¢ã™
2. è¦‹ã¤ã‘ãŸè¦å®šã®åŸæ–‡ã‚’ä¸€å­—ä¸€å¥å¤‰æ›´ã›ãšã‚³ãƒ”ãƒ¼ã™ã‚‹
3. è¦ç´„ãƒ»è¨€ã„æ›ãˆãƒ»è§£é‡ˆãƒ»çŸ­ç¸®ãƒ»AIç‹¬è‡ªã®è¡¨ç¾è¿½åŠ ã¯çµ¶å¯¾ç¦æ­¢
4. ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚„è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å¼•ç”¨ã—ã¦ã¯ã„ã‘ãªã„
5. è¦‹å‡ºã—ï¼ˆ###ã€####ãªã©ï¼‰ã‚‚å¿…ãšå«ã‚ã‚‹
6. æœ€ä½ã§ã‚‚3ã€œ5è¡Œç¨‹åº¦ã®æ–‡è„ˆã‚’å«ã‚ã‚‹

**âŒ çµ¶å¯¾ã«ã‚„ã£ã¦ã¯ã„ã‘ãªã„ã“ã¨:**
- ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å¼•ç”¨ï¼ˆä¾‹ï¼šã€ŒãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ãŒé•·ã™ãã‚‹ãŸã‚...ã€ï¼‰
- AIè‡ªèº«ã®è§£é‡ˆã‚„è¦ç´„ã®è¿½åŠ 
- çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã«ãªã„å†…å®¹ã®æé€ 
- ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ç¹°ã‚Šè¿”ã™ã ã‘ã§èª¬æ˜ãŒãªã„å¼•ç”¨
- è¦‹å‡ºã—ã‚’çœç•¥ã—ãŸçŸ­ã™ãã‚‹å¼•ç”¨

**âœ… è‰¯ã„ä¾‹:**
"referenceKnowledge": {
  "file": "25_ã‚¯ãƒè¡¨ç¾ã«ã¤ã„ã¦.txt",
  "excerpt": "##### **ã€Œã‚¯ãƒã€ã¨ã„ã†è¡¨ç¾ã‚’ä½¿ã„ãŸã„æ™‚**\nä»¥ä¸‹ã®æ³¨è¨˜ã¨ã‚»ãƒƒãƒˆã§ä½¿ç”¨ã—ã¦ä¸‹ã•ã„ã€‚\nâ€»ä¹¾ç‡¥ã‚„å¤ã„è§’è³ªã«ã‚ˆã‚‹ãã™ã¿ã€ãƒãƒªãŒä¸è¶³ã—ãŸæš—ã„ç›®ã®ä¸‹"
}

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      // Debug: Log the prompt being sent to Gemini (first attempt only to avoid spam)
      if (attempt === 0) {
        console.log('');
        console.log('========== GEMINI PROMPT for', segment.id, '==========');
        console.log('Segment text:', segment.text);
        console.log('Product ID:', productId);
        console.log('Knowledge context (', knowledgeContext.length, 'chars):');
        console.log(knowledgeContext.substring(0, 500) + '...');
        console.log('========== END PROMPT ==========');
        console.log('');
      }

      const result = await model.generateContent(prompt);
      const responseText = result.response.text();

      // Debug: Log the raw response
      console.log('');
      console.log('========== GEMINI RESPONSE for', segment.id, '(attempt', attempt + 1, ') ==========');
      console.log(responseText);
      console.log('========== END RESPONSE ==========');
      console.log('');

      // Parse JSON response
      const evaluation = parseJsonResponse<SegmentEvaluation>(responseText);

      // Normalize violation types to valid enum values and validate required fields
      if (evaluation.violations && Array.isArray(evaluation.violations)) {
        evaluation.violations = evaluation.violations.map((violation, vIndex) => {
          const validTypes = ['ç¤¾å†…åŸºæº–é•å', 'è–¬æ©Ÿæ³•é•å', 'æ™¯è¡¨æ³•é•å', 'ç‰¹å•†æ³•é•å', 'ãã®ä»–'];
          if (!validTypes.includes(violation.type)) {
            console.warn('[Evaluate] Invalid violation type', violation.type, ', mapping to ãã®ä»–');
            violation.type = 'ãã®ä»–' as const;
          }

          // Validate referenceKnowledge
          if (!violation.referenceKnowledge?.file) {
            console.error('[Evaluate] CRITICAL: Missing referenceKnowledge.file for', segment.id, 'violation', vIndex + 1);
            console.error('[Evaluate] Violation description:', violation.description);
            violation.referenceKnowledge = {
              ...violation.referenceKnowledge,
              file: 'ã€ã‚¨ãƒ©ãƒ¼ï¼šå‚ç…§å…ƒãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‘',
              excerpt: violation.referenceKnowledge?.excerpt || 'ã€ã‚¨ãƒ©ãƒ¼ï¼šçŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã®å¼•ç”¨ãŒæ¬ è½ã—ã¦ã„ã¾ã™ã€‘'
            };
          }

          // Validate excerpt
          if (!violation.referenceKnowledge?.excerpt || violation.referenceKnowledge.excerpt.length < 10) {
            console.error('[Evaluate] CRITICAL: Missing or too short referenceKnowledge.excerpt for', segment.id, 'violation', vIndex + 1);
            console.error('[Evaluate] File:', violation.referenceKnowledge?.file);
            if (!violation.referenceKnowledge.excerpt) {
              violation.referenceKnowledge.excerpt = 'ã€ã‚¨ãƒ©ãƒ¼ï¼šçŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã®å¼•ç”¨ãŒæ¬ è½ã—ã¦ã„ã¾ã™ã€‚è©•ä¾¡ã‚’å†å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‘';
            }
          }

          // Issue #13: Advanced knowledge excerpt validation
          if (violation.referenceKnowledge?.excerpt && violation.referenceKnowledge.file) {
            const validationResult = validateKnowledgeExcerpt(
              violation.referenceKnowledge.excerpt,
              violation.referenceKnowledge.file
            );

            // Log validation results
            logValidationResult(segment.id, violation.referenceKnowledge.file, validationResult);

            // Check for fabricated content
            if (detectFabricatedContent(violation.referenceKnowledge.excerpt)) {
              console.error(`[Evaluate] ğŸš¨ FABRICATED CONTENT DETECTED in ${segment.id}!`);
              console.error(`[Evaluate] File: ${violation.referenceKnowledge.file}`);
              console.error(`[Evaluate] Excerpt: ${violation.referenceKnowledge.excerpt.substring(0, 200)}`);
              console.error(`[Evaluate] This excerpt contains known fabricated patterns. AI may be generating content not in knowledge base.`);
            }

            // If validation failed with critical errors, log them
            if (!validationResult.isValid) {
              console.error(`[Evaluate] âŒ Knowledge excerpt validation failed for ${segment.id}`);
              console.error(`[Evaluate] Errors: ${validationResult.errors.join(', ')}`);
            }
          }

          // ã€é‡è¦ã€‘æ ¹æ‹ ãŒãªã„å ´åˆã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
          // çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã«ãƒ«ãƒ¼ãƒ«è‡ªä½“ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
          // ã€Œå†…å®¹ãŒä¸€è‡´ã—ãªã„ã€ã€ŒæœŸé–“ãŒç•°ãªã‚‹ã€ç­‰ã®é•åã¯æ­£å½“ãªã®ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ãªã„
          const excerpt = violation.referenceKnowledge?.excerpt || '';

          // ãƒ«ãƒ¼ãƒ«è‡ªä½“ãŒå­˜åœ¨ã—ãªã„ã“ã¨ã‚’ç¤ºã™ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆã“ã‚Œã‚‰ã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å¯¾è±¡ï¼‰
          const noRulePatterns = [
            'åŒæ§˜ã®è¡¨ç¾ã«é–¢ã™ã‚‹è¨˜è¿°ã¯è¦‹å½“ãŸã‚‰ãš',
            'è©²å½“ã™ã‚‹è¦å®šã¯è¦‹å½“ãŸã‚‰ãš',
            'ã“ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«é–¢ã™ã‚‹è¨˜è¿°ã¯è¦‹å½“ãŸã‚‰ãš',
            'é–¢é€£ã™ã‚‹è¨˜è¼‰ãªã—',
            'è©²å½“ã™ã‚‹è¨˜è¼‰ãªã—',
            'çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã«è¨˜è¼‰ãªã—',
            'è¦å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
            'æ˜ç¢ºãªè¦å®šãŒç¢ºèªã§ãã¾ã›ã‚“ã§ã—ãŸ'
          ];

          const hasNoRule = noRulePatterns.some(pattern => excerpt.includes(pattern));

          // å†…å®¹ã®ä¸ä¸€è‡´ã‚’ç¤ºã™ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆã“ã‚Œã‚‰ã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ãªã„ - æ­£å½“ãªé•åï¼‰
          const contentMismatchPatterns = [
            'æœŸé–“ãŒ',
            'å†…å®¹ãŒ',
            'å¹´æ•°ãŒ',
            'ä¸€è‡´',
            'ç•°ãªã‚‹',
            'çŸ›ç›¾',
            'ç›¸é•',
            'ä¸æ•´åˆ'
          ];

          const hasContentMismatch = contentMismatchPatterns.some(pattern => excerpt.includes(pattern));

          if (hasNoRule && !hasContentMismatch) {
            console.warn(`[Evaluate] âš ï¸ INVALID VIOLATION DETECTED: ${segment.id} violation ${vIndex + 1}`);
            console.warn(`[Evaluate] Excerpt indicates no rule exists: ${excerpt.substring(0, 200)}`);
            console.warn(`[Evaluate] This violation will be REMOVED as it has no basis in knowledge base.`);
            // ã“ã®é•åã‚’nullã«ãƒãƒ¼ã‚¯ã—ã¦å¾Œã§å‰Šé™¤
            return null;
          }

          // Validate correctionSuggestion
          if (!violation.correctionSuggestion || violation.correctionSuggestion.length < 5) {
            console.error(`[Evaluate] âš ï¸ CRITICAL: Missing or too short correctionSuggestion for ${segment.id} violation ${vIndex + 1}`);
            console.error(`[Evaluate] Description: ${violation.description}`);
            console.error(`[Evaluate] File: ${violation.referenceKnowledge?.file}`);
            violation.correctionSuggestion = 'ã€ã‚¨ãƒ©ãƒ¼ï¼šå…·ä½“çš„ãªä¿®æ­£æ¡ˆãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã€Œ' +
              (violation.referenceKnowledge?.file || 'ä¸æ˜') +
              'ã€ã‚’å‚ç…§ã—ã€è©²å½“ã™ã‚‹ä¿®æ­£æ¡ˆãƒ»å¯¾ç­–ãƒ»æ¨å¥¨è¡¨ç¾ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‘';
          }

          return violation;
        }).filter((v): v is NonNullable<typeof v> => v !== null); // æ ¹æ‹ ã®ãªã„é•åã‚’é™¤å¤–
      }

      // ã€é‡è¦ã€‘é•åãŒ0ä»¶ã«ãªã£ãŸå ´åˆã€complianceã‚’trueã«æ›´æ–°
      if (evaluation.violations.length === 0 && evaluation.compliance === false) {
        console.log(`[Evaluate] âœ“ Correcting compliance: ${segment.id} has no valid violations, setting compliance = true`);
        evaluation.compliance = true;
      }

      // Add metadata
      evaluation.evaluatedAt = new Date().toISOString();
      evaluation.processingTimeMs = Date.now() - startTime;

      // Validate result
      if (!evaluation.segmentId || evaluation.compliance === undefined) {
        throw new Error('Invalid evaluation response format');
      }

      return evaluation;

    } catch (error) {
      const isLastAttempt = attempt === maxRetries;
      const errorMessage = error instanceof Error ? error.message : String(error);

      // Check if it's a rate limit error
      const isRateLimitError = errorMessage.includes('429') ||
                               errorMessage.includes('rate limit') ||
                               errorMessage.includes('quota');

      if (isLastAttempt) {
        console.error(`[Evaluate] âŒ Failed segment ${segment.id} after ${maxRetries + 1} attempts`);
        console.error(`[Evaluate] Final error: ${errorMessage}`);
        throw error;
      }

      // Calculate backoff delay
      // For rate limit errors: 10s, 20s, 40s (exponential with base 10)
      // For other errors: 1s, 2s, 3s (linear)
      const baseDelay = isRateLimitError ? 10000 : 1000;
      const backoffMultiplier = isRateLimitError ? Math.pow(2, attempt) : (attempt + 1);
      const backoffDelay = baseDelay * backoffMultiplier;

      console.warn(`[Evaluate] âš ï¸ Attempt ${attempt + 1}/${maxRetries + 1} failed for segment ${segment.id}`);
      console.warn(`[Evaluate] Error type: ${isRateLimitError ? 'Rate Limit' : 'Other'}`);
      console.warn(`[Evaluate] Error message: ${errorMessage.substring(0, 200)}...`);
      console.warn(`[Evaluate] Retrying in ${backoffDelay}ms (${Math.round(backoffDelay / 1000)}s)...`);

      await delay(backoffDelay);
    }
  }

  // Should never reach here
  throw new Error(`Failed to evaluate segment ${segment.id} after ${maxRetries + 1} attempts`);
}

/**
 * Parse JSON response from Gemini, handling various formats
 */
function parseJsonResponse<T>(responseText: string): T {
  // Clean up response text
  const cleanText = responseText.trim();

  // Try direct parse first
  try {
    const result = JSON.parse(cleanText);
    console.log('[Parse] Direct parse succeeded');
    return result;
  } catch (directError) {
    console.log('[Parse] Direct parse failed, attempting extraction...');

    // Extract JSON from markdown code blocks
    const jsonMatch = cleanText.match(/```json\s*([\s\S]*?)\s*```/) ||
                      cleanText.match(/```\s*([\s\S]*?)\s*```/) ||
                      cleanText.match(/(\{[\s\S]*\}|\[[\s\S]*\])/);

    if (!jsonMatch) {
      console.error('[Parse] No JSON found in response');
      throw new Error('Failed to extract JSON from response');
    }

    const extractedJson = jsonMatch[1].trim();
    console.log('[Parse] Extracted JSON length:', extractedJson.length);
    console.log('[Parse] First 200 chars:', extractedJson.substring(0, 200));

    // Try parsing the extracted JSON
    try {
      const result = JSON.parse(extractedJson);
      console.log('[Parse] Extracted JSON parse succeeded');
      return result;
    } catch (firstError) {
      console.log('[Parse] Extracted JSON parse failed, applying fixControlCharacters...');

      // If parsing fails, fix control characters
      try {
        const fixedJson = fixControlCharacters(extractedJson);
        console.log('[Parse] After fixControlCharacters, first 200 chars:', fixedJson.substring(0, 200));
        const result = JSON.parse(fixedJson);
        console.log('[Parse] Fixed JSON parse succeeded');
        return result;
      } catch (secondError) {
        console.error('[Parse] All parsing attempts failed');
        console.error('[Parse] Original error:', firstError);
        console.error('[Parse] After fix error:', secondError);
        throw new Error(`Failed to parse JSON after all attempts: ${secondError}`);
      }
    }
  }
}

/**
 * Fix unescaped control characters in JSON string
 * This function scans through JSON and properly escapes control characters within string literals
 */
function fixControlCharacters(jsonStr: string): string {
  let result = '';
  let inString = false;
  let escapeNext = false;

  for (let i = 0; i < jsonStr.length; i++) {
    const char = jsonStr[i];
    const charCode = char.charCodeAt(0);

    // Handle escape sequences
    if (escapeNext) {
      result += char;
      escapeNext = false;
      continue;
    }

    if (char === '\\') {
      result += char;
      escapeNext = true;
      continue;
    }

    // Toggle string mode
    if (char === '"') {
      result += char;
      inString = !inString;
      continue;
    }

    // If we're inside a string, check for control characters
    if (inString && charCode < 32) {
      // Escape control characters
      switch (char) {
        case '\n':
          result += '\\n';
          break;
        case '\r':
          result += '\\r';
          break;
        case '\t':
          result += '\\t';
          break;
        case '\f':
          result += '\\f';
          break;
        case '\b':
          result += '\\b';
          break;
        default:
          // For other control characters, use unicode escape
          result += '\\u' + ('0000' + charCode.toString(16)).slice(-4);
          break;
      }
    } else {
      result += char;
    }
  }

  return result;
}

/**
 * Delay execution for specified milliseconds
 */
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Calculate adaptive delay based on segment count and token consumption
 *
 * Gemini API Limits:
 * - Free tier: 15 RPM (Requests Per Minute), 250,000 TPM (Tokens Per Minute)
 * - Token consumption: ~15,000 tokens per request (with knowledge base)
 *
 * @param segmentIndex - Current segment index
 * @param totalSegments - Total number of segments
 * @param estimatedTokensPerRequest - Estimated tokens per request (default: 15000)
 * @returns Delay time in milliseconds
 */
function calculateAdaptiveDelay(
  segmentIndex: number,
  totalSegments: number,
  estimatedTokensPerRequest: number = 15000
): number {
  const TOKEN_LIMIT_PER_MINUTE = 250000;
  const REQUEST_LIMIT_PER_MINUTE = 10; // Conservative estimate (free tier: 15 RPM)

  // Delay based on token limit: (60s * tokens_per_request) / token_limit
  const delayForTokenLimit = (60 * 1000 * estimatedTokensPerRequest) / TOKEN_LIMIT_PER_MINUTE;

  // Delay based on request limit: 60s / request_limit
  const delayForRequestLimit = (60 * 1000) / REQUEST_LIMIT_PER_MINUTE;

  // Use the more conservative (larger) delay
  let baseDelay = Math.max(delayForTokenLimit, delayForRequestLimit);

  // For large batches (15+ segments), add 50% buffer to be extra safe
  if (totalSegments > 15) {
    baseDelay = baseDelay * 1.5;
    console.log(`[Adaptive Delay] Large batch detected (${totalSegments} segments), applying 50% buffer`);
  }

  console.log(`[Adaptive Delay] Segment ${segmentIndex + 1}/${totalSegments}: ${Math.round(baseDelay)}ms`);
  console.log(`  - Token limit delay: ${Math.round(delayForTokenLimit)}ms`);
  console.log(`  - Request limit delay: ${Math.round(delayForRequestLimit)}ms`);
  console.log(`  - Final delay: ${Math.round(baseDelay)}ms`);

  return baseDelay;
}

/**
 * GET /api/v2/evaluate
 * API documentation and health check
 */
export async function GET() {
  return NextResponse.json({
    name: 'RAG-based Legal Compliance Evaluation API',
    version: 'v2',
    description: 'ã‚»ã‚°ãƒ¡ãƒ³ãƒˆå˜ä½ã§è–¬æ©Ÿæ³•ãƒ»æ™¯è¡¨æ³•ãƒ»ç¤¾å†…åŸºæº–ã«åŸºã¥ã„ãŸæ³•ä»¤éµå®ˆãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ',
    endpoints: {
      POST: {
        path: '/api/v2/evaluate',
        description: 'ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®æ³•ä»¤éµå®ˆè©•ä¾¡',
        requestBody: {
          segments: 'Segment[] (required)',
          productId: "'HA' | 'SH' (required)",
          apiKey: 'string (required, Gemini API key)',
          knowledgeContext: 'string (optional, pre-loaded knowledge)',
        },
        response: {
          success: 'boolean',
          data: {
            evaluations: 'SegmentEvaluation[]',
            summary: {
              totalSegments: 'number',
              evaluatedSegments: 'number',
              compliantSegments: 'number',
              violationCount: 'number',
            },
            productId: 'string',
            processingTimeMs: 'number',
          },
        },
      },
    },
    features: [
      'RAG-based evaluation using knowledge base',
      'Parallel processing with max 3 concurrent requests',
      'Automatic retry on failure',
      'Detailed violation identification with knowledge citation',
      'Correction suggestions based on regulations',
    ],
    evaluationCriteria: [
      'è–¬æ©Ÿæ³•é•å (Pharmaceutical Affairs Law violations)',
      'æ™¯è¡¨æ³•é•å (Misleading Representations violations)',
      'ç¤¾å†…åŸºæº–é•å (Internal standards violations)',
    ],
    example: {
      request: {
        segments: [
          {
            id: 'seg_001',
            text: 'ã‚·ãƒ¯ã‚’æ”¹å–„ã™ã‚‹ç¾å®¹æ¶²',
            type: 'claim',
            position: { start: 0, end: 12 },
            importance: 0.9,
          },
        ],
        productId: 'HA',
        apiKey: 'your-gemini-api-key',
      },
      response: {
        success: true,
        data: {
          evaluations: [
            {
              segmentId: 'seg_001',
              compliance: false,
              violations: [
                {
                  type: 'è–¬æ©Ÿæ³•é•å',
                  severity: 'high',
                  description: 'ã€Œã‚·ãƒ¯ã‚’æ”¹å–„ã€ã¯åŒ»è–¬éƒ¨å¤–å“ã®æ‰¿èªåŠ¹èƒ½ã‚’è¶…ãˆã‚‹è¡¨ç¾ã§ã™',
                  referenceKnowledge: {
                    file: '22_ã‚·ãƒ¯è¡¨ç¾ã«ã¤ã„ã¦ã®è¦å®šã¨ç¤¾å†…è¦å®š.txt',
                    excerpt: 'ã‚·ãƒ¯æ”¹å–„åŠ¹æœã‚’è¬³ãˆã‚‹ã®ã¯æ‰¿èªã‚’å¾—ãŸåŒ»è–¬éƒ¨å¤–å“ã®ã¿',
                  },
                  correctionSuggestion: 'ã€Œä¹¾ç‡¥ã«ã‚ˆã‚‹å°ã‚¸ãƒ¯ã‚’ç›®ç«‹ãŸãªãã™ã‚‹ã€ç­‰ã®è¡¨ç¾ã«å¤‰æ›´',
                  confidence: 0.95,
                },
              ],
              evaluatedAt: '2025-10-15T10:00:00.000Z',
              processingTimeMs: 1500,
            },
          ],
          summary: {
            totalSegments: 1,
            evaluatedSegments: 1,
            compliantSegments: 0,
            violationCount: 1,
          },
          productId: 'HA',
          processingTimeMs: 2000,
        },
      },
    },
  });
}
